
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model chat
 * 
 */
export type chat = $Result.DefaultSelection<Prisma.$chatPayload>
/**
 * Model code
 * 
 */
export type code = $Result.DefaultSelection<Prisma.$codePayload>
/**
 * Model permission
 * 
 */
export type permission = $Result.DefaultSelection<Prisma.$permissionPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model video
 * 
 */
export type video = $Result.DefaultSelection<Prisma.$videoPayload>
/**
 * Model video_comment
 * 
 */
export type video_comment = $Result.DefaultSelection<Prisma.$video_commentPayload>
/**
 * Model video_like
 * 
 */
export type video_like = $Result.DefaultSelection<Prisma.$video_likePayload>
/**
 * Model video_type
 * 
 */
export type video_type = $Result.DefaultSelection<Prisma.$video_typePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Chats
 * const chats = await prisma.chat.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Chats
   * const chats = await prisma.chat.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.chat`: Exposes CRUD operations for the **chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.chatDelegate<ExtArgs>;

  /**
   * `prisma.code`: Exposes CRUD operations for the **code** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Codes
    * const codes = await prisma.code.findMany()
    * ```
    */
  get code(): Prisma.codeDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.permissionDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.videoDelegate<ExtArgs>;

  /**
   * `prisma.video_comment`: Exposes CRUD operations for the **video_comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Video_comments
    * const video_comments = await prisma.video_comment.findMany()
    * ```
    */
  get video_comment(): Prisma.video_commentDelegate<ExtArgs>;

  /**
   * `prisma.video_like`: Exposes CRUD operations for the **video_like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Video_likes
    * const video_likes = await prisma.video_like.findMany()
    * ```
    */
  get video_like(): Prisma.video_likeDelegate<ExtArgs>;

  /**
   * `prisma.video_type`: Exposes CRUD operations for the **video_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Video_types
    * const video_types = await prisma.video_type.findMany()
    * ```
    */
  get video_type(): Prisma.video_typeDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.21.1
   * Query Engine version: bf0e5e8a04cada8225617067eaa03d041e2bba36
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    chat: 'chat',
    code: 'code',
    permission: 'permission',
    role: 'role',
    users: 'users',
    video: 'video',
    video_comment: 'video_comment',
    video_like: 'video_like',
    video_type: 'video_type'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "chat" | "code" | "permission" | "role" | "users" | "video" | "video_comment" | "video_like" | "video_type"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      chat: {
        payload: Prisma.$chatPayload<ExtArgs>
        fields: Prisma.chatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          findFirst: {
            args: Prisma.chatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          findMany: {
            args: Prisma.chatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>[]
          }
          create: {
            args: Prisma.chatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          createMany: {
            args: Prisma.chatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.chatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          update: {
            args: Prisma.chatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          deleteMany: {
            args: Prisma.chatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.chatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.chatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      code: {
        payload: Prisma.$codePayload<ExtArgs>
        fields: Prisma.codeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.codeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$codePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.codeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$codePayload>
          }
          findFirst: {
            args: Prisma.codeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$codePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.codeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$codePayload>
          }
          findMany: {
            args: Prisma.codeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$codePayload>[]
          }
          create: {
            args: Prisma.codeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$codePayload>
          }
          createMany: {
            args: Prisma.codeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.codeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$codePayload>
          }
          update: {
            args: Prisma.codeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$codePayload>
          }
          deleteMany: {
            args: Prisma.codeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.codeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.codeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$codePayload>
          }
          aggregate: {
            args: Prisma.CodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCode>
          }
          groupBy: {
            args: Prisma.codeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.codeCountArgs<ExtArgs>
            result: $Utils.Optional<CodeCountAggregateOutputType> | number
          }
        }
      }
      permission: {
        payload: Prisma.$permissionPayload<ExtArgs>
        fields: Prisma.permissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          findFirst: {
            args: Prisma.permissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          findMany: {
            args: Prisma.permissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          create: {
            args: Prisma.permissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          createMany: {
            args: Prisma.permissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.permissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          update: {
            args: Prisma.permissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          deleteMany: {
            args: Prisma.permissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.permissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.permissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      video: {
        payload: Prisma.$videoPayload<ExtArgs>
        fields: Prisma.videoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoPayload>
          }
          findFirst: {
            args: Prisma.videoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoPayload>
          }
          findMany: {
            args: Prisma.videoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoPayload>[]
          }
          create: {
            args: Prisma.videoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoPayload>
          }
          createMany: {
            args: Prisma.videoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.videoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoPayload>
          }
          update: {
            args: Prisma.videoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoPayload>
          }
          deleteMany: {
            args: Prisma.videoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.videoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.videoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.videoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.videoCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      video_comment: {
        payload: Prisma.$video_commentPayload<ExtArgs>
        fields: Prisma.video_commentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.video_commentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_commentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.video_commentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_commentPayload>
          }
          findFirst: {
            args: Prisma.video_commentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_commentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.video_commentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_commentPayload>
          }
          findMany: {
            args: Prisma.video_commentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_commentPayload>[]
          }
          create: {
            args: Prisma.video_commentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_commentPayload>
          }
          createMany: {
            args: Prisma.video_commentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.video_commentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_commentPayload>
          }
          update: {
            args: Prisma.video_commentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_commentPayload>
          }
          deleteMany: {
            args: Prisma.video_commentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.video_commentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.video_commentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_commentPayload>
          }
          aggregate: {
            args: Prisma.Video_commentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo_comment>
          }
          groupBy: {
            args: Prisma.video_commentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Video_commentGroupByOutputType>[]
          }
          count: {
            args: Prisma.video_commentCountArgs<ExtArgs>
            result: $Utils.Optional<Video_commentCountAggregateOutputType> | number
          }
        }
      }
      video_like: {
        payload: Prisma.$video_likePayload<ExtArgs>
        fields: Prisma.video_likeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.video_likeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_likePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.video_likeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_likePayload>
          }
          findFirst: {
            args: Prisma.video_likeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_likePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.video_likeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_likePayload>
          }
          findMany: {
            args: Prisma.video_likeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_likePayload>[]
          }
          create: {
            args: Prisma.video_likeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_likePayload>
          }
          createMany: {
            args: Prisma.video_likeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.video_likeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_likePayload>
          }
          update: {
            args: Prisma.video_likeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_likePayload>
          }
          deleteMany: {
            args: Prisma.video_likeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.video_likeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.video_likeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_likePayload>
          }
          aggregate: {
            args: Prisma.Video_likeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo_like>
          }
          groupBy: {
            args: Prisma.video_likeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Video_likeGroupByOutputType>[]
          }
          count: {
            args: Prisma.video_likeCountArgs<ExtArgs>
            result: $Utils.Optional<Video_likeCountAggregateOutputType> | number
          }
        }
      }
      video_type: {
        payload: Prisma.$video_typePayload<ExtArgs>
        fields: Prisma.video_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.video_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.video_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_typePayload>
          }
          findFirst: {
            args: Prisma.video_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.video_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_typePayload>
          }
          findMany: {
            args: Prisma.video_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_typePayload>[]
          }
          create: {
            args: Prisma.video_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_typePayload>
          }
          createMany: {
            args: Prisma.video_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.video_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_typePayload>
          }
          update: {
            args: Prisma.video_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_typePayload>
          }
          deleteMany: {
            args: Prisma.video_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.video_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.video_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$video_typePayload>
          }
          aggregate: {
            args: Prisma.Video_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo_type>
          }
          groupBy: {
            args: Prisma.video_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Video_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.video_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Video_typeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    video: number
    video_comment: number
    video_like: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | UsersCountOutputTypeCountVideoArgs
    video_comment?: boolean | UsersCountOutputTypeCountVideo_commentArgs
    video_like?: boolean | UsersCountOutputTypeCountVideo_likeArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videoWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVideo_commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: video_commentWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVideo_likeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: video_likeWhereInput
  }


  /**
   * Count Type VideoCountOutputType
   */

  export type VideoCountOutputType = {
    video_comment: number
    video_like: number
  }

  export type VideoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video_comment?: boolean | VideoCountOutputTypeCountVideo_commentArgs
    video_like?: boolean | VideoCountOutputTypeCountVideo_likeArgs
  }

  // Custom InputTypes
  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCountOutputType
     */
    select?: VideoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountVideo_commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: video_commentWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountVideo_likeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: video_likeWhereInput
  }


  /**
   * Count Type Video_typeCountOutputType
   */

  export type Video_typeCountOutputType = {
    video: number
  }

  export type Video_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | Video_typeCountOutputTypeCountVideoArgs
  }

  // Custom InputTypes
  /**
   * Video_typeCountOutputType without action
   */
  export type Video_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video_typeCountOutputType
     */
    select?: Video_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Video_typeCountOutputType without action
   */
  export type Video_typeCountOutputTypeCountVideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ChatSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ChatMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    content: string | null
    room_id: string | null
    date: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    content: string | null
    room_id: string | null
    date: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    user_id: number
    content: number
    room_id: number
    date: number
    _all: number
  }


  export type ChatAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ChatSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ChatMinAggregateInputType = {
    id?: true
    user_id?: true
    content?: true
    room_id?: true
    date?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    user_id?: true
    content?: true
    room_id?: true
    date?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    user_id?: true
    content?: true
    room_id?: true
    date?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat to aggregate.
     */
    where?: chatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatOrderByWithRelationInput | chatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type chatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatWhereInput
    orderBy?: chatOrderByWithAggregationInput | chatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: chatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _avg?: ChatAvgAggregateInputType
    _sum?: ChatSumAggregateInputType
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: number
    user_id: number | null
    content: string | null
    room_id: string | null
    date: Date | null
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends chatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type chatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    content?: boolean
    room_id?: boolean
    date?: boolean
  }, ExtArgs["result"]["chat"]>


  export type chatSelectScalar = {
    id?: boolean
    user_id?: boolean
    content?: boolean
    room_id?: boolean
    date?: boolean
  }


  export type $chatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      content: string | null
      room_id: string | null
      date: Date | null
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type chatGetPayload<S extends boolean | null | undefined | chatDefaultArgs> = $Result.GetResult<Prisma.$chatPayload, S>

  type chatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<chatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface chatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat'], meta: { name: 'chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {chatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatFindUniqueArgs>(args: SelectSubset<T, chatFindUniqueArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {chatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatFindUniqueOrThrowArgs>(args: SelectSubset<T, chatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatFindFirstArgs>(args?: SelectSubset<T, chatFindFirstArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatFindFirstOrThrowArgs>(args?: SelectSubset<T, chatFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatFindManyArgs>(args?: SelectSubset<T, chatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat.
     * @param {chatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends chatCreateArgs>(args: SelectSubset<T, chatCreateArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chats.
     * @param {chatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatCreateManyArgs>(args?: SelectSubset<T, chatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chat.
     * @param {chatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends chatDeleteArgs>(args: SelectSubset<T, chatDeleteArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat.
     * @param {chatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatUpdateArgs>(args: SelectSubset<T, chatUpdateArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chats.
     * @param {chatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatDeleteManyArgs>(args?: SelectSubset<T, chatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatUpdateManyArgs>(args: SelectSubset<T, chatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {chatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends chatUpsertArgs>(args: SelectSubset<T, chatUpsertArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends chatCountArgs>(
      args?: Subset<T, chatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatGroupByArgs['orderBy'] }
        : { orderBy?: chatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat model
   */
  readonly fields: chatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat model
   */ 
  interface chatFieldRefs {
    readonly id: FieldRef<"chat", 'Int'>
    readonly user_id: FieldRef<"chat", 'Int'>
    readonly content: FieldRef<"chat", 'String'>
    readonly room_id: FieldRef<"chat", 'String'>
    readonly date: FieldRef<"chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chat findUnique
   */
  export type chatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Filter, which chat to fetch.
     */
    where: chatWhereUniqueInput
  }

  /**
   * chat findUniqueOrThrow
   */
  export type chatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Filter, which chat to fetch.
     */
    where: chatWhereUniqueInput
  }

  /**
   * chat findFirst
   */
  export type chatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Filter, which chat to fetch.
     */
    where?: chatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatOrderByWithRelationInput | chatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * chat findFirstOrThrow
   */
  export type chatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Filter, which chat to fetch.
     */
    where?: chatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatOrderByWithRelationInput | chatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * chat findMany
   */
  export type chatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatOrderByWithRelationInput | chatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chats.
     */
    cursor?: chatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * chat create
   */
  export type chatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * The data needed to create a chat.
     */
    data?: XOR<chatCreateInput, chatUncheckedCreateInput>
  }

  /**
   * chat createMany
   */
  export type chatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chats.
     */
    data: chatCreateManyInput | chatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat update
   */
  export type chatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * The data needed to update a chat.
     */
    data: XOR<chatUpdateInput, chatUncheckedUpdateInput>
    /**
     * Choose, which chat to update.
     */
    where: chatWhereUniqueInput
  }

  /**
   * chat updateMany
   */
  export type chatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chats.
     */
    data: XOR<chatUpdateManyMutationInput, chatUncheckedUpdateManyInput>
    /**
     * Filter which chats to update
     */
    where?: chatWhereInput
  }

  /**
   * chat upsert
   */
  export type chatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * The filter to search for the chat to update in case it exists.
     */
    where: chatWhereUniqueInput
    /**
     * In case the chat found by the `where` argument doesn't exist, create a new chat with this data.
     */
    create: XOR<chatCreateInput, chatUncheckedCreateInput>
    /**
     * In case the chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatUpdateInput, chatUncheckedUpdateInput>
  }

  /**
   * chat delete
   */
  export type chatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Filter which chat to delete.
     */
    where: chatWhereUniqueInput
  }

  /**
   * chat deleteMany
   */
  export type chatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chats to delete
     */
    where?: chatWhereInput
  }

  /**
   * chat without action
   */
  export type chatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
  }


  /**
   * Model code
   */

  export type AggregateCode = {
    _count: CodeCountAggregateOutputType | null
    _avg: CodeAvgAggregateOutputType | null
    _sum: CodeSumAggregateOutputType | null
    _min: CodeMinAggregateOutputType | null
    _max: CodeMaxAggregateOutputType | null
  }

  export type CodeAvgAggregateOutputType = {
    id: number | null
  }

  export type CodeSumAggregateOutputType = {
    id: bigint | null
  }

  export type CodeMinAggregateOutputType = {
    id: bigint | null
    code: string | null
    expired: Date | null
  }

  export type CodeMaxAggregateOutputType = {
    id: bigint | null
    code: string | null
    expired: Date | null
  }

  export type CodeCountAggregateOutputType = {
    id: number
    code: number
    expired: number
    _all: number
  }


  export type CodeAvgAggregateInputType = {
    id?: true
  }

  export type CodeSumAggregateInputType = {
    id?: true
  }

  export type CodeMinAggregateInputType = {
    id?: true
    code?: true
    expired?: true
  }

  export type CodeMaxAggregateInputType = {
    id?: true
    code?: true
    expired?: true
  }

  export type CodeCountAggregateInputType = {
    id?: true
    code?: true
    expired?: true
    _all?: true
  }

  export type CodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which code to aggregate.
     */
    where?: codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codes to fetch.
     */
    orderBy?: codeOrderByWithRelationInput | codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned codes
    **/
    _count?: true | CodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeMaxAggregateInputType
  }

  export type GetCodeAggregateType<T extends CodeAggregateArgs> = {
        [P in keyof T & keyof AggregateCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCode[P]>
      : GetScalarType<T[P], AggregateCode[P]>
  }




  export type codeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: codeWhereInput
    orderBy?: codeOrderByWithAggregationInput | codeOrderByWithAggregationInput[]
    by: CodeScalarFieldEnum[] | CodeScalarFieldEnum
    having?: codeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeCountAggregateInputType | true
    _avg?: CodeAvgAggregateInputType
    _sum?: CodeSumAggregateInputType
    _min?: CodeMinAggregateInputType
    _max?: CodeMaxAggregateInputType
  }

  export type CodeGroupByOutputType = {
    id: bigint
    code: string | null
    expired: Date | null
    _count: CodeCountAggregateOutputType | null
    _avg: CodeAvgAggregateOutputType | null
    _sum: CodeSumAggregateOutputType | null
    _min: CodeMinAggregateOutputType | null
    _max: CodeMaxAggregateOutputType | null
  }

  type GetCodeGroupByPayload<T extends codeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodeGroupByOutputType[P]>
            : GetScalarType<T[P], CodeGroupByOutputType[P]>
        }
      >
    >


  export type codeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    expired?: boolean
  }, ExtArgs["result"]["code"]>


  export type codeSelectScalar = {
    id?: boolean
    code?: boolean
    expired?: boolean
  }


  export type $codePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "code"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      code: string | null
      expired: Date | null
    }, ExtArgs["result"]["code"]>
    composites: {}
  }

  type codeGetPayload<S extends boolean | null | undefined | codeDefaultArgs> = $Result.GetResult<Prisma.$codePayload, S>

  type codeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<codeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CodeCountAggregateInputType | true
    }

  export interface codeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['code'], meta: { name: 'code' } }
    /**
     * Find zero or one Code that matches the filter.
     * @param {codeFindUniqueArgs} args - Arguments to find a Code
     * @example
     * // Get one Code
     * const code = await prisma.code.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends codeFindUniqueArgs>(args: SelectSubset<T, codeFindUniqueArgs<ExtArgs>>): Prisma__codeClient<$Result.GetResult<Prisma.$codePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Code that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {codeFindUniqueOrThrowArgs} args - Arguments to find a Code
     * @example
     * // Get one Code
     * const code = await prisma.code.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends codeFindUniqueOrThrowArgs>(args: SelectSubset<T, codeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__codeClient<$Result.GetResult<Prisma.$codePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Code that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeFindFirstArgs} args - Arguments to find a Code
     * @example
     * // Get one Code
     * const code = await prisma.code.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends codeFindFirstArgs>(args?: SelectSubset<T, codeFindFirstArgs<ExtArgs>>): Prisma__codeClient<$Result.GetResult<Prisma.$codePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Code that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeFindFirstOrThrowArgs} args - Arguments to find a Code
     * @example
     * // Get one Code
     * const code = await prisma.code.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends codeFindFirstOrThrowArgs>(args?: SelectSubset<T, codeFindFirstOrThrowArgs<ExtArgs>>): Prisma__codeClient<$Result.GetResult<Prisma.$codePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Codes
     * const codes = await prisma.code.findMany()
     * 
     * // Get first 10 Codes
     * const codes = await prisma.code.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codeWithIdOnly = await prisma.code.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends codeFindManyArgs>(args?: SelectSubset<T, codeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$codePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Code.
     * @param {codeCreateArgs} args - Arguments to create a Code.
     * @example
     * // Create one Code
     * const Code = await prisma.code.create({
     *   data: {
     *     // ... data to create a Code
     *   }
     * })
     * 
     */
    create<T extends codeCreateArgs>(args: SelectSubset<T, codeCreateArgs<ExtArgs>>): Prisma__codeClient<$Result.GetResult<Prisma.$codePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Codes.
     * @param {codeCreateManyArgs} args - Arguments to create many Codes.
     * @example
     * // Create many Codes
     * const code = await prisma.code.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends codeCreateManyArgs>(args?: SelectSubset<T, codeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Code.
     * @param {codeDeleteArgs} args - Arguments to delete one Code.
     * @example
     * // Delete one Code
     * const Code = await prisma.code.delete({
     *   where: {
     *     // ... filter to delete one Code
     *   }
     * })
     * 
     */
    delete<T extends codeDeleteArgs>(args: SelectSubset<T, codeDeleteArgs<ExtArgs>>): Prisma__codeClient<$Result.GetResult<Prisma.$codePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Code.
     * @param {codeUpdateArgs} args - Arguments to update one Code.
     * @example
     * // Update one Code
     * const code = await prisma.code.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends codeUpdateArgs>(args: SelectSubset<T, codeUpdateArgs<ExtArgs>>): Prisma__codeClient<$Result.GetResult<Prisma.$codePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Codes.
     * @param {codeDeleteManyArgs} args - Arguments to filter Codes to delete.
     * @example
     * // Delete a few Codes
     * const { count } = await prisma.code.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends codeDeleteManyArgs>(args?: SelectSubset<T, codeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Codes
     * const code = await prisma.code.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends codeUpdateManyArgs>(args: SelectSubset<T, codeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Code.
     * @param {codeUpsertArgs} args - Arguments to update or create a Code.
     * @example
     * // Update or create a Code
     * const code = await prisma.code.upsert({
     *   create: {
     *     // ... data to create a Code
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Code we want to update
     *   }
     * })
     */
    upsert<T extends codeUpsertArgs>(args: SelectSubset<T, codeUpsertArgs<ExtArgs>>): Prisma__codeClient<$Result.GetResult<Prisma.$codePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeCountArgs} args - Arguments to filter Codes to count.
     * @example
     * // Count the number of Codes
     * const count = await prisma.code.count({
     *   where: {
     *     // ... the filter for the Codes we want to count
     *   }
     * })
    **/
    count<T extends codeCountArgs>(
      args?: Subset<T, codeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Code.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeAggregateArgs>(args: Subset<T, CodeAggregateArgs>): Prisma.PrismaPromise<GetCodeAggregateType<T>>

    /**
     * Group by Code.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends codeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: codeGroupByArgs['orderBy'] }
        : { orderBy?: codeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, codeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the code model
   */
  readonly fields: codeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for code.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__codeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the code model
   */ 
  interface codeFieldRefs {
    readonly id: FieldRef<"code", 'BigInt'>
    readonly code: FieldRef<"code", 'String'>
    readonly expired: FieldRef<"code", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * code findUnique
   */
  export type codeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the code
     */
    select?: codeSelect<ExtArgs> | null
    /**
     * Filter, which code to fetch.
     */
    where: codeWhereUniqueInput
  }

  /**
   * code findUniqueOrThrow
   */
  export type codeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the code
     */
    select?: codeSelect<ExtArgs> | null
    /**
     * Filter, which code to fetch.
     */
    where: codeWhereUniqueInput
  }

  /**
   * code findFirst
   */
  export type codeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the code
     */
    select?: codeSelect<ExtArgs> | null
    /**
     * Filter, which code to fetch.
     */
    where?: codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codes to fetch.
     */
    orderBy?: codeOrderByWithRelationInput | codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for codes.
     */
    cursor?: codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of codes.
     */
    distinct?: CodeScalarFieldEnum | CodeScalarFieldEnum[]
  }

  /**
   * code findFirstOrThrow
   */
  export type codeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the code
     */
    select?: codeSelect<ExtArgs> | null
    /**
     * Filter, which code to fetch.
     */
    where?: codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codes to fetch.
     */
    orderBy?: codeOrderByWithRelationInput | codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for codes.
     */
    cursor?: codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of codes.
     */
    distinct?: CodeScalarFieldEnum | CodeScalarFieldEnum[]
  }

  /**
   * code findMany
   */
  export type codeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the code
     */
    select?: codeSelect<ExtArgs> | null
    /**
     * Filter, which codes to fetch.
     */
    where?: codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codes to fetch.
     */
    orderBy?: codeOrderByWithRelationInput | codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing codes.
     */
    cursor?: codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codes.
     */
    skip?: number
    distinct?: CodeScalarFieldEnum | CodeScalarFieldEnum[]
  }

  /**
   * code create
   */
  export type codeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the code
     */
    select?: codeSelect<ExtArgs> | null
    /**
     * The data needed to create a code.
     */
    data?: XOR<codeCreateInput, codeUncheckedCreateInput>
  }

  /**
   * code createMany
   */
  export type codeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many codes.
     */
    data: codeCreateManyInput | codeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * code update
   */
  export type codeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the code
     */
    select?: codeSelect<ExtArgs> | null
    /**
     * The data needed to update a code.
     */
    data: XOR<codeUpdateInput, codeUncheckedUpdateInput>
    /**
     * Choose, which code to update.
     */
    where: codeWhereUniqueInput
  }

  /**
   * code updateMany
   */
  export type codeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update codes.
     */
    data: XOR<codeUpdateManyMutationInput, codeUncheckedUpdateManyInput>
    /**
     * Filter which codes to update
     */
    where?: codeWhereInput
  }

  /**
   * code upsert
   */
  export type codeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the code
     */
    select?: codeSelect<ExtArgs> | null
    /**
     * The filter to search for the code to update in case it exists.
     */
    where: codeWhereUniqueInput
    /**
     * In case the code found by the `where` argument doesn't exist, create a new code with this data.
     */
    create: XOR<codeCreateInput, codeUncheckedCreateInput>
    /**
     * In case the code was found with the provided `where` argument, update it with this data.
     */
    update: XOR<codeUpdateInput, codeUncheckedUpdateInput>
  }

  /**
   * code delete
   */
  export type codeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the code
     */
    select?: codeSelect<ExtArgs> | null
    /**
     * Filter which code to delete.
     */
    where: codeWhereUniqueInput
  }

  /**
   * code deleteMany
   */
  export type codeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which codes to delete
     */
    where?: codeWhereInput
  }

  /**
   * code without action
   */
  export type codeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the code
     */
    select?: codeSelect<ExtArgs> | null
  }


  /**
   * Model permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    permission_id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    permission_id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    permission_id: number | null
    permission_name: string | null
    description: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    permission_id: number | null
    permission_name: string | null
    description: string | null
  }

  export type PermissionCountAggregateOutputType = {
    permission_id: number
    permission_name: number
    description: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    permission_id?: true
  }

  export type PermissionSumAggregateInputType = {
    permission_id?: true
  }

  export type PermissionMinAggregateInputType = {
    permission_id?: true
    permission_name?: true
    description?: true
  }

  export type PermissionMaxAggregateInputType = {
    permission_id?: true
    permission_name?: true
    description?: true
  }

  export type PermissionCountAggregateInputType = {
    permission_id?: true
    permission_name?: true
    description?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission to aggregate.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type permissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionWhereInput
    orderBy?: permissionOrderByWithAggregationInput | permissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: permissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    permission_id: number
    permission_name: string | null
    description: string | null
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends permissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type permissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    permission_name?: boolean
    description?: boolean
  }, ExtArgs["result"]["permission"]>


  export type permissionSelectScalar = {
    permission_id?: boolean
    permission_name?: boolean
    description?: boolean
  }


  export type $permissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      permission_id: number
      permission_name: string | null
      description: string | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type permissionGetPayload<S extends boolean | null | undefined | permissionDefaultArgs> = $Result.GetResult<Prisma.$permissionPayload, S>

  type permissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<permissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface permissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permission'], meta: { name: 'permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {permissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionFindUniqueArgs>(args: SelectSubset<T, permissionFindUniqueArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {permissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionFindFirstArgs>(args?: SelectSubset<T, permissionFindFirstArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `permission_id`
     * const permissionWithPermission_idOnly = await prisma.permission.findMany({ select: { permission_id: true } })
     * 
     */
    findMany<T extends permissionFindManyArgs>(args?: SelectSubset<T, permissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {permissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends permissionCreateArgs>(args: SelectSubset<T, permissionCreateArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {permissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionCreateManyArgs>(args?: SelectSubset<T, permissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {permissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends permissionDeleteArgs>(args: SelectSubset<T, permissionDeleteArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {permissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionUpdateArgs>(args: SelectSubset<T, permissionUpdateArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {permissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionDeleteManyArgs>(args?: SelectSubset<T, permissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionUpdateManyArgs>(args: SelectSubset<T, permissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {permissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends permissionUpsertArgs>(args: SelectSubset<T, permissionUpsertArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionCountArgs>(
      args?: Subset<T, permissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionGroupByArgs['orderBy'] }
        : { orderBy?: permissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permission model
   */
  readonly fields: permissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permission model
   */ 
  interface permissionFieldRefs {
    readonly permission_id: FieldRef<"permission", 'Int'>
    readonly permission_name: FieldRef<"permission", 'String'>
    readonly description: FieldRef<"permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * permission findUnique
   */
  export type permissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findUniqueOrThrow
   */
  export type permissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findFirst
   */
  export type permissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission findFirstOrThrow
   */
  export type permissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission findMany
   */
  export type permissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission create
   */
  export type permissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * The data needed to create a permission.
     */
    data?: XOR<permissionCreateInput, permissionUncheckedCreateInput>
  }

  /**
   * permission createMany
   */
  export type permissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionCreateManyInput | permissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission update
   */
  export type permissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * The data needed to update a permission.
     */
    data: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
    /**
     * Choose, which permission to update.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission updateMany
   */
  export type permissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
  }

  /**
   * permission upsert
   */
  export type permissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * The filter to search for the permission to update in case it exists.
     */
    where: permissionWhereUniqueInput
    /**
     * In case the permission found by the `where` argument doesn't exist, create a new permission with this data.
     */
    create: XOR<permissionCreateInput, permissionUncheckedCreateInput>
    /**
     * In case the permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
  }

  /**
   * permission delete
   */
  export type permissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Filter which permission to delete.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission deleteMany
   */
  export type permissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionWhereInput
  }

  /**
   * permission without action
   */
  export type permissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
  }


  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    role_id: number | null
  }

  export type RoleSumAggregateOutputType = {
    role_id: number | null
  }

  export type RoleMinAggregateOutputType = {
    role_id: number | null
    role_name: string | null
    list_permission: string | null
  }

  export type RoleMaxAggregateOutputType = {
    role_id: number | null
    role_name: string | null
    list_permission: string | null
  }

  export type RoleCountAggregateOutputType = {
    role_id: number
    role_name: number
    list_permission: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    role_id?: true
  }

  export type RoleSumAggregateInputType = {
    role_id?: true
  }

  export type RoleMinAggregateInputType = {
    role_id?: true
    role_name?: true
    list_permission?: true
  }

  export type RoleMaxAggregateInputType = {
    role_id?: true
    role_name?: true
    list_permission?: true
  }

  export type RoleCountAggregateInputType = {
    role_id?: true
    role_name?: true
    list_permission?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    role_id: number
    role_name: string | null
    list_permission: string | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    list_permission?: boolean
    users?: boolean | role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>


  export type roleSelectScalar = {
    role_id?: boolean
    role_name?: boolean
    list_permission?: boolean
  }

  export type roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      role_name: string | null
      list_permission: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const roleWithRole_idOnly = await prisma.role.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends roleFindManyArgs>(args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends roleCreateArgs>(args: SelectSubset<T, roleCreateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleCreateManyArgs>(args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends roleDeleteArgs>(args: SelectSubset<T, roleDeleteArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleUpdateArgs>(args: SelectSubset<T, roleUpdateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleDeleteManyArgs>(args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleUpdateManyArgs>(args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(args: SelectSubset<T, roleUpsertArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends role$usersArgs<ExtArgs> = {}>(args?: Subset<T, role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role model
   */ 
  interface roleFieldRefs {
    readonly role_id: FieldRef<"role", 'Int'>
    readonly role_name: FieldRef<"role", 'String'>
    readonly list_permission: FieldRef<"role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data?: XOR<roleCreateInput, roleUncheckedCreateInput>
  }

  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
  }

  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }

  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
  }

  /**
   * role.users
   */
  export type role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    user_id: number | null
    full_name: string | null
    email: string | null
    avatar: string | null
    pass_word: string | null
    face_app_id: string | null
    role_id: number | null
    refresh_token: string | null
  }

  export type UsersMaxAggregateOutputType = {
    user_id: number | null
    full_name: string | null
    email: string | null
    avatar: string | null
    pass_word: string | null
    face_app_id: string | null
    role_id: number | null
    refresh_token: string | null
  }

  export type UsersCountAggregateOutputType = {
    user_id: number
    full_name: number
    email: number
    avatar: number
    pass_word: number
    face_app_id: number
    role_id: number
    refresh_token: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type UsersSumAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type UsersMinAggregateInputType = {
    user_id?: true
    full_name?: true
    email?: true
    avatar?: true
    pass_word?: true
    face_app_id?: true
    role_id?: true
    refresh_token?: true
  }

  export type UsersMaxAggregateInputType = {
    user_id?: true
    full_name?: true
    email?: true
    avatar?: true
    pass_word?: true
    face_app_id?: true
    role_id?: true
    refresh_token?: true
  }

  export type UsersCountAggregateInputType = {
    user_id?: true
    full_name?: true
    email?: true
    avatar?: true
    pass_word?: true
    face_app_id?: true
    role_id?: true
    refresh_token?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    user_id: number
    full_name: string | null
    email: string | null
    avatar: string | null
    pass_word: string | null
    face_app_id: string | null
    role_id: number | null
    refresh_token: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    full_name?: boolean
    email?: boolean
    avatar?: boolean
    pass_word?: boolean
    face_app_id?: boolean
    role_id?: boolean
    refresh_token?: boolean
    role?: boolean | users$roleArgs<ExtArgs>
    video?: boolean | users$videoArgs<ExtArgs>
    video_comment?: boolean | users$video_commentArgs<ExtArgs>
    video_like?: boolean | users$video_likeArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>


  export type usersSelectScalar = {
    user_id?: boolean
    full_name?: boolean
    email?: boolean
    avatar?: boolean
    pass_word?: boolean
    face_app_id?: boolean
    role_id?: boolean
    refresh_token?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | users$roleArgs<ExtArgs>
    video?: boolean | users$videoArgs<ExtArgs>
    video_comment?: boolean | users$video_commentArgs<ExtArgs>
    video_like?: boolean | users$video_likeArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      role: Prisma.$rolePayload<ExtArgs> | null
      video: Prisma.$videoPayload<ExtArgs>[]
      video_comment: Prisma.$video_commentPayload<ExtArgs>[]
      video_like: Prisma.$video_likePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      full_name: string | null
      email: string | null
      avatar: string | null
      pass_word: string | null
      face_app_id: string | null
      role_id: number | null
      refresh_token: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const usersWithUser_idOnly = await prisma.users.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends users$roleArgs<ExtArgs> = {}>(args?: Subset<T, users$roleArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    video<T extends users$videoArgs<ExtArgs> = {}>(args?: Subset<T, users$videoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "findMany"> | Null>
    video_comment<T extends users$video_commentArgs<ExtArgs> = {}>(args?: Subset<T, users$video_commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "findMany"> | Null>
    video_like<T extends users$video_likeArgs<ExtArgs> = {}>(args?: Subset<T, users$video_likeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly user_id: FieldRef<"users", 'Int'>
    readonly full_name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly avatar: FieldRef<"users", 'String'>
    readonly pass_word: FieldRef<"users", 'String'>
    readonly face_app_id: FieldRef<"users", 'String'>
    readonly role_id: FieldRef<"users", 'Int'>
    readonly refresh_token: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data?: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.role
   */
  export type users$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    where?: roleWhereInput
  }

  /**
   * users.video
   */
  export type users$videoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    where?: videoWhereInput
    orderBy?: videoOrderByWithRelationInput | videoOrderByWithRelationInput[]
    cursor?: videoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * users.video_comment
   */
  export type users$video_commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    where?: video_commentWhereInput
    orderBy?: video_commentOrderByWithRelationInput | video_commentOrderByWithRelationInput[]
    cursor?: video_commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Video_commentScalarFieldEnum | Video_commentScalarFieldEnum[]
  }

  /**
   * users.video_like
   */
  export type users$video_likeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    where?: video_likeWhereInput
    orderBy?: video_likeOrderByWithRelationInput | video_likeOrderByWithRelationInput[]
    cursor?: video_likeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Video_likeScalarFieldEnum | Video_likeScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    video_id: number | null
    views: number | null
    user_id: number | null
    type_id: number | null
  }

  export type VideoSumAggregateOutputType = {
    video_id: number | null
    views: number | null
    user_id: number | null
    type_id: number | null
  }

  export type VideoMinAggregateOutputType = {
    video_id: number | null
    video_name: string | null
    thumbnail: string | null
    description: string | null
    views: number | null
    source: string | null
    user_id: number | null
    type_id: number | null
  }

  export type VideoMaxAggregateOutputType = {
    video_id: number | null
    video_name: string | null
    thumbnail: string | null
    description: string | null
    views: number | null
    source: string | null
    user_id: number | null
    type_id: number | null
  }

  export type VideoCountAggregateOutputType = {
    video_id: number
    video_name: number
    thumbnail: number
    description: number
    views: number
    source: number
    user_id: number
    type_id: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    video_id?: true
    views?: true
    user_id?: true
    type_id?: true
  }

  export type VideoSumAggregateInputType = {
    video_id?: true
    views?: true
    user_id?: true
    type_id?: true
  }

  export type VideoMinAggregateInputType = {
    video_id?: true
    video_name?: true
    thumbnail?: true
    description?: true
    views?: true
    source?: true
    user_id?: true
    type_id?: true
  }

  export type VideoMaxAggregateInputType = {
    video_id?: true
    video_name?: true
    thumbnail?: true
    description?: true
    views?: true
    source?: true
    user_id?: true
    type_id?: true
  }

  export type VideoCountAggregateInputType = {
    video_id?: true
    video_name?: true
    thumbnail?: true
    description?: true
    views?: true
    source?: true
    user_id?: true
    type_id?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which video to aggregate.
     */
    where?: videoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videoOrderByWithRelationInput | videoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type videoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videoWhereInput
    orderBy?: videoOrderByWithAggregationInput | videoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: videoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    video_id: number
    video_name: string | null
    thumbnail: string | null
    description: string | null
    views: number | null
    source: string | null
    user_id: number | null
    type_id: number | null
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends videoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type videoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    video_id?: boolean
    video_name?: boolean
    thumbnail?: boolean
    description?: boolean
    views?: boolean
    source?: boolean
    user_id?: boolean
    type_id?: boolean
    users?: boolean | video$usersArgs<ExtArgs>
    video_type?: boolean | video$video_typeArgs<ExtArgs>
    video_comment?: boolean | video$video_commentArgs<ExtArgs>
    video_like?: boolean | video$video_likeArgs<ExtArgs>
    _count?: boolean | VideoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>


  export type videoSelectScalar = {
    video_id?: boolean
    video_name?: boolean
    thumbnail?: boolean
    description?: boolean
    views?: boolean
    source?: boolean
    user_id?: boolean
    type_id?: boolean
  }

  export type videoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | video$usersArgs<ExtArgs>
    video_type?: boolean | video$video_typeArgs<ExtArgs>
    video_comment?: boolean | video$video_commentArgs<ExtArgs>
    video_like?: boolean | video$video_likeArgs<ExtArgs>
    _count?: boolean | VideoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $videoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "video"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
      video_type: Prisma.$video_typePayload<ExtArgs> | null
      video_comment: Prisma.$video_commentPayload<ExtArgs>[]
      video_like: Prisma.$video_likePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      video_id: number
      video_name: string | null
      thumbnail: string | null
      description: string | null
      views: number | null
      source: string | null
      user_id: number | null
      type_id: number | null
    }, ExtArgs["result"]["video"]>
    composites: {}
  }

  type videoGetPayload<S extends boolean | null | undefined | videoDefaultArgs> = $Result.GetResult<Prisma.$videoPayload, S>

  type videoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<videoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface videoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['video'], meta: { name: 'video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {videoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends videoFindUniqueArgs>(args: SelectSubset<T, videoFindUniqueArgs<ExtArgs>>): Prisma__videoClient<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Video that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {videoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends videoFindUniqueOrThrowArgs>(args: SelectSubset<T, videoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__videoClient<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends videoFindFirstArgs>(args?: SelectSubset<T, videoFindFirstArgs<ExtArgs>>): Prisma__videoClient<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends videoFindFirstOrThrowArgs>(args?: SelectSubset<T, videoFindFirstOrThrowArgs<ExtArgs>>): Prisma__videoClient<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `video_id`
     * const videoWithVideo_idOnly = await prisma.video.findMany({ select: { video_id: true } })
     * 
     */
    findMany<T extends videoFindManyArgs>(args?: SelectSubset<T, videoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Video.
     * @param {videoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
     */
    create<T extends videoCreateArgs>(args: SelectSubset<T, videoCreateArgs<ExtArgs>>): Prisma__videoClient<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Videos.
     * @param {videoCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends videoCreateManyArgs>(args?: SelectSubset<T, videoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Video.
     * @param {videoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
     */
    delete<T extends videoDeleteArgs>(args: SelectSubset<T, videoDeleteArgs<ExtArgs>>): Prisma__videoClient<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Video.
     * @param {videoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends videoUpdateArgs>(args: SelectSubset<T, videoUpdateArgs<ExtArgs>>): Prisma__videoClient<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Videos.
     * @param {videoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends videoDeleteManyArgs>(args?: SelectSubset<T, videoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends videoUpdateManyArgs>(args: SelectSubset<T, videoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {videoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
     */
    upsert<T extends videoUpsertArgs>(args: SelectSubset<T, videoUpsertArgs<ExtArgs>>): Prisma__videoClient<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends videoCountArgs>(
      args?: Subset<T, videoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videoGroupByArgs['orderBy'] }
        : { orderBy?: videoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the video model
   */
  readonly fields: videoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends video$usersArgs<ExtArgs> = {}>(args?: Subset<T, video$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    video_type<T extends video$video_typeArgs<ExtArgs> = {}>(args?: Subset<T, video$video_typeArgs<ExtArgs>>): Prisma__video_typeClient<$Result.GetResult<Prisma.$video_typePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    video_comment<T extends video$video_commentArgs<ExtArgs> = {}>(args?: Subset<T, video$video_commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "findMany"> | Null>
    video_like<T extends video$video_likeArgs<ExtArgs> = {}>(args?: Subset<T, video$video_likeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the video model
   */ 
  interface videoFieldRefs {
    readonly video_id: FieldRef<"video", 'Int'>
    readonly video_name: FieldRef<"video", 'String'>
    readonly thumbnail: FieldRef<"video", 'String'>
    readonly description: FieldRef<"video", 'String'>
    readonly views: FieldRef<"video", 'Int'>
    readonly source: FieldRef<"video", 'String'>
    readonly user_id: FieldRef<"video", 'Int'>
    readonly type_id: FieldRef<"video", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * video findUnique
   */
  export type videoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    /**
     * Filter, which video to fetch.
     */
    where: videoWhereUniqueInput
  }

  /**
   * video findUniqueOrThrow
   */
  export type videoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    /**
     * Filter, which video to fetch.
     */
    where: videoWhereUniqueInput
  }

  /**
   * video findFirst
   */
  export type videoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    /**
     * Filter, which video to fetch.
     */
    where?: videoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videoOrderByWithRelationInput | videoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos.
     */
    cursor?: videoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * video findFirstOrThrow
   */
  export type videoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    /**
     * Filter, which video to fetch.
     */
    where?: videoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videoOrderByWithRelationInput | videoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos.
     */
    cursor?: videoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * video findMany
   */
  export type videoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videoOrderByWithRelationInput | videoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos.
     */
    cursor?: videoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * video create
   */
  export type videoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    /**
     * The data needed to create a video.
     */
    data?: XOR<videoCreateInput, videoUncheckedCreateInput>
  }

  /**
   * video createMany
   */
  export type videoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos.
     */
    data: videoCreateManyInput | videoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * video update
   */
  export type videoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    /**
     * The data needed to update a video.
     */
    data: XOR<videoUpdateInput, videoUncheckedUpdateInput>
    /**
     * Choose, which video to update.
     */
    where: videoWhereUniqueInput
  }

  /**
   * video updateMany
   */
  export type videoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos.
     */
    data: XOR<videoUpdateManyMutationInput, videoUncheckedUpdateManyInput>
    /**
     * Filter which videos to update
     */
    where?: videoWhereInput
  }

  /**
   * video upsert
   */
  export type videoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    /**
     * The filter to search for the video to update in case it exists.
     */
    where: videoWhereUniqueInput
    /**
     * In case the video found by the `where` argument doesn't exist, create a new video with this data.
     */
    create: XOR<videoCreateInput, videoUncheckedCreateInput>
    /**
     * In case the video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videoUpdateInput, videoUncheckedUpdateInput>
  }

  /**
   * video delete
   */
  export type videoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    /**
     * Filter which video to delete.
     */
    where: videoWhereUniqueInput
  }

  /**
   * video deleteMany
   */
  export type videoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos to delete
     */
    where?: videoWhereInput
  }

  /**
   * video.users
   */
  export type video$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * video.video_type
   */
  export type video$video_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
    where?: video_typeWhereInput
  }

  /**
   * video.video_comment
   */
  export type video$video_commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    where?: video_commentWhereInput
    orderBy?: video_commentOrderByWithRelationInput | video_commentOrderByWithRelationInput[]
    cursor?: video_commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Video_commentScalarFieldEnum | Video_commentScalarFieldEnum[]
  }

  /**
   * video.video_like
   */
  export type video$video_likeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    where?: video_likeWhereInput
    orderBy?: video_likeOrderByWithRelationInput | video_likeOrderByWithRelationInput[]
    cursor?: video_likeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Video_likeScalarFieldEnum | Video_likeScalarFieldEnum[]
  }

  /**
   * video without action
   */
  export type videoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
  }


  /**
   * Model video_comment
   */

  export type AggregateVideo_comment = {
    _count: Video_commentCountAggregateOutputType | null
    _avg: Video_commentAvgAggregateOutputType | null
    _sum: Video_commentSumAggregateOutputType | null
    _min: Video_commentMinAggregateOutputType | null
    _max: Video_commentMaxAggregateOutputType | null
  }

  export type Video_commentAvgAggregateOutputType = {
    comment_id: number | null
    user_id: number | null
    video_id: number | null
  }

  export type Video_commentSumAggregateOutputType = {
    comment_id: number | null
    user_id: number | null
    video_id: number | null
  }

  export type Video_commentMinAggregateOutputType = {
    comment_id: number | null
    user_id: number | null
    video_id: number | null
    date_create: Date | null
    content: string | null
    reply_list: string | null
    timestamp: Date | null
  }

  export type Video_commentMaxAggregateOutputType = {
    comment_id: number | null
    user_id: number | null
    video_id: number | null
    date_create: Date | null
    content: string | null
    reply_list: string | null
    timestamp: Date | null
  }

  export type Video_commentCountAggregateOutputType = {
    comment_id: number
    user_id: number
    video_id: number
    date_create: number
    content: number
    reply_list: number
    timestamp: number
    _all: number
  }


  export type Video_commentAvgAggregateInputType = {
    comment_id?: true
    user_id?: true
    video_id?: true
  }

  export type Video_commentSumAggregateInputType = {
    comment_id?: true
    user_id?: true
    video_id?: true
  }

  export type Video_commentMinAggregateInputType = {
    comment_id?: true
    user_id?: true
    video_id?: true
    date_create?: true
    content?: true
    reply_list?: true
    timestamp?: true
  }

  export type Video_commentMaxAggregateInputType = {
    comment_id?: true
    user_id?: true
    video_id?: true
    date_create?: true
    content?: true
    reply_list?: true
    timestamp?: true
  }

  export type Video_commentCountAggregateInputType = {
    comment_id?: true
    user_id?: true
    video_id?: true
    date_create?: true
    content?: true
    reply_list?: true
    timestamp?: true
    _all?: true
  }

  export type Video_commentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which video_comment to aggregate.
     */
    where?: video_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_comments to fetch.
     */
    orderBy?: video_commentOrderByWithRelationInput | video_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: video_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned video_comments
    **/
    _count?: true | Video_commentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Video_commentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Video_commentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Video_commentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Video_commentMaxAggregateInputType
  }

  export type GetVideo_commentAggregateType<T extends Video_commentAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo_comment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo_comment[P]>
      : GetScalarType<T[P], AggregateVideo_comment[P]>
  }




  export type video_commentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: video_commentWhereInput
    orderBy?: video_commentOrderByWithAggregationInput | video_commentOrderByWithAggregationInput[]
    by: Video_commentScalarFieldEnum[] | Video_commentScalarFieldEnum
    having?: video_commentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Video_commentCountAggregateInputType | true
    _avg?: Video_commentAvgAggregateInputType
    _sum?: Video_commentSumAggregateInputType
    _min?: Video_commentMinAggregateInputType
    _max?: Video_commentMaxAggregateInputType
  }

  export type Video_commentGroupByOutputType = {
    comment_id: number
    user_id: number | null
    video_id: number | null
    date_create: Date | null
    content: string | null
    reply_list: string | null
    timestamp: Date | null
    _count: Video_commentCountAggregateOutputType | null
    _avg: Video_commentAvgAggregateOutputType | null
    _sum: Video_commentSumAggregateOutputType | null
    _min: Video_commentMinAggregateOutputType | null
    _max: Video_commentMaxAggregateOutputType | null
  }

  type GetVideo_commentGroupByPayload<T extends video_commentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Video_commentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Video_commentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Video_commentGroupByOutputType[P]>
            : GetScalarType<T[P], Video_commentGroupByOutputType[P]>
        }
      >
    >


  export type video_commentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    user_id?: boolean
    video_id?: boolean
    date_create?: boolean
    content?: boolean
    reply_list?: boolean
    timestamp?: boolean
    users?: boolean | video_comment$usersArgs<ExtArgs>
    video?: boolean | video_comment$videoArgs<ExtArgs>
  }, ExtArgs["result"]["video_comment"]>


  export type video_commentSelectScalar = {
    comment_id?: boolean
    user_id?: boolean
    video_id?: boolean
    date_create?: boolean
    content?: boolean
    reply_list?: boolean
    timestamp?: boolean
  }

  export type video_commentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | video_comment$usersArgs<ExtArgs>
    video?: boolean | video_comment$videoArgs<ExtArgs>
  }

  export type $video_commentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "video_comment"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
      video: Prisma.$videoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      comment_id: number
      user_id: number | null
      video_id: number | null
      date_create: Date | null
      content: string | null
      reply_list: string | null
      timestamp: Date | null
    }, ExtArgs["result"]["video_comment"]>
    composites: {}
  }

  type video_commentGetPayload<S extends boolean | null | undefined | video_commentDefaultArgs> = $Result.GetResult<Prisma.$video_commentPayload, S>

  type video_commentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<video_commentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Video_commentCountAggregateInputType | true
    }

  export interface video_commentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['video_comment'], meta: { name: 'video_comment' } }
    /**
     * Find zero or one Video_comment that matches the filter.
     * @param {video_commentFindUniqueArgs} args - Arguments to find a Video_comment
     * @example
     * // Get one Video_comment
     * const video_comment = await prisma.video_comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends video_commentFindUniqueArgs>(args: SelectSubset<T, video_commentFindUniqueArgs<ExtArgs>>): Prisma__video_commentClient<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Video_comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {video_commentFindUniqueOrThrowArgs} args - Arguments to find a Video_comment
     * @example
     * // Get one Video_comment
     * const video_comment = await prisma.video_comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends video_commentFindUniqueOrThrowArgs>(args: SelectSubset<T, video_commentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__video_commentClient<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Video_comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_commentFindFirstArgs} args - Arguments to find a Video_comment
     * @example
     * // Get one Video_comment
     * const video_comment = await prisma.video_comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends video_commentFindFirstArgs>(args?: SelectSubset<T, video_commentFindFirstArgs<ExtArgs>>): Prisma__video_commentClient<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Video_comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_commentFindFirstOrThrowArgs} args - Arguments to find a Video_comment
     * @example
     * // Get one Video_comment
     * const video_comment = await prisma.video_comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends video_commentFindFirstOrThrowArgs>(args?: SelectSubset<T, video_commentFindFirstOrThrowArgs<ExtArgs>>): Prisma__video_commentClient<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Video_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_commentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Video_comments
     * const video_comments = await prisma.video_comment.findMany()
     * 
     * // Get first 10 Video_comments
     * const video_comments = await prisma.video_comment.findMany({ take: 10 })
     * 
     * // Only select the `comment_id`
     * const video_commentWithComment_idOnly = await prisma.video_comment.findMany({ select: { comment_id: true } })
     * 
     */
    findMany<T extends video_commentFindManyArgs>(args?: SelectSubset<T, video_commentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Video_comment.
     * @param {video_commentCreateArgs} args - Arguments to create a Video_comment.
     * @example
     * // Create one Video_comment
     * const Video_comment = await prisma.video_comment.create({
     *   data: {
     *     // ... data to create a Video_comment
     *   }
     * })
     * 
     */
    create<T extends video_commentCreateArgs>(args: SelectSubset<T, video_commentCreateArgs<ExtArgs>>): Prisma__video_commentClient<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Video_comments.
     * @param {video_commentCreateManyArgs} args - Arguments to create many Video_comments.
     * @example
     * // Create many Video_comments
     * const video_comment = await prisma.video_comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends video_commentCreateManyArgs>(args?: SelectSubset<T, video_commentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Video_comment.
     * @param {video_commentDeleteArgs} args - Arguments to delete one Video_comment.
     * @example
     * // Delete one Video_comment
     * const Video_comment = await prisma.video_comment.delete({
     *   where: {
     *     // ... filter to delete one Video_comment
     *   }
     * })
     * 
     */
    delete<T extends video_commentDeleteArgs>(args: SelectSubset<T, video_commentDeleteArgs<ExtArgs>>): Prisma__video_commentClient<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Video_comment.
     * @param {video_commentUpdateArgs} args - Arguments to update one Video_comment.
     * @example
     * // Update one Video_comment
     * const video_comment = await prisma.video_comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends video_commentUpdateArgs>(args: SelectSubset<T, video_commentUpdateArgs<ExtArgs>>): Prisma__video_commentClient<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Video_comments.
     * @param {video_commentDeleteManyArgs} args - Arguments to filter Video_comments to delete.
     * @example
     * // Delete a few Video_comments
     * const { count } = await prisma.video_comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends video_commentDeleteManyArgs>(args?: SelectSubset<T, video_commentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Video_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_commentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Video_comments
     * const video_comment = await prisma.video_comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends video_commentUpdateManyArgs>(args: SelectSubset<T, video_commentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video_comment.
     * @param {video_commentUpsertArgs} args - Arguments to update or create a Video_comment.
     * @example
     * // Update or create a Video_comment
     * const video_comment = await prisma.video_comment.upsert({
     *   create: {
     *     // ... data to create a Video_comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video_comment we want to update
     *   }
     * })
     */
    upsert<T extends video_commentUpsertArgs>(args: SelectSubset<T, video_commentUpsertArgs<ExtArgs>>): Prisma__video_commentClient<$Result.GetResult<Prisma.$video_commentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Video_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_commentCountArgs} args - Arguments to filter Video_comments to count.
     * @example
     * // Count the number of Video_comments
     * const count = await prisma.video_comment.count({
     *   where: {
     *     // ... the filter for the Video_comments we want to count
     *   }
     * })
    **/
    count<T extends video_commentCountArgs>(
      args?: Subset<T, video_commentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Video_commentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video_comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Video_commentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Video_commentAggregateArgs>(args: Subset<T, Video_commentAggregateArgs>): Prisma.PrismaPromise<GetVideo_commentAggregateType<T>>

    /**
     * Group by Video_comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_commentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends video_commentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: video_commentGroupByArgs['orderBy'] }
        : { orderBy?: video_commentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, video_commentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideo_commentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the video_comment model
   */
  readonly fields: video_commentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for video_comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__video_commentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends video_comment$usersArgs<ExtArgs> = {}>(args?: Subset<T, video_comment$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    video<T extends video_comment$videoArgs<ExtArgs> = {}>(args?: Subset<T, video_comment$videoArgs<ExtArgs>>): Prisma__videoClient<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the video_comment model
   */ 
  interface video_commentFieldRefs {
    readonly comment_id: FieldRef<"video_comment", 'Int'>
    readonly user_id: FieldRef<"video_comment", 'Int'>
    readonly video_id: FieldRef<"video_comment", 'Int'>
    readonly date_create: FieldRef<"video_comment", 'DateTime'>
    readonly content: FieldRef<"video_comment", 'String'>
    readonly reply_list: FieldRef<"video_comment", 'String'>
    readonly timestamp: FieldRef<"video_comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * video_comment findUnique
   */
  export type video_commentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    /**
     * Filter, which video_comment to fetch.
     */
    where: video_commentWhereUniqueInput
  }

  /**
   * video_comment findUniqueOrThrow
   */
  export type video_commentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    /**
     * Filter, which video_comment to fetch.
     */
    where: video_commentWhereUniqueInput
  }

  /**
   * video_comment findFirst
   */
  export type video_commentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    /**
     * Filter, which video_comment to fetch.
     */
    where?: video_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_comments to fetch.
     */
    orderBy?: video_commentOrderByWithRelationInput | video_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for video_comments.
     */
    cursor?: video_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of video_comments.
     */
    distinct?: Video_commentScalarFieldEnum | Video_commentScalarFieldEnum[]
  }

  /**
   * video_comment findFirstOrThrow
   */
  export type video_commentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    /**
     * Filter, which video_comment to fetch.
     */
    where?: video_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_comments to fetch.
     */
    orderBy?: video_commentOrderByWithRelationInput | video_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for video_comments.
     */
    cursor?: video_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of video_comments.
     */
    distinct?: Video_commentScalarFieldEnum | Video_commentScalarFieldEnum[]
  }

  /**
   * video_comment findMany
   */
  export type video_commentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    /**
     * Filter, which video_comments to fetch.
     */
    where?: video_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_comments to fetch.
     */
    orderBy?: video_commentOrderByWithRelationInput | video_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing video_comments.
     */
    cursor?: video_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_comments.
     */
    skip?: number
    distinct?: Video_commentScalarFieldEnum | Video_commentScalarFieldEnum[]
  }

  /**
   * video_comment create
   */
  export type video_commentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    /**
     * The data needed to create a video_comment.
     */
    data?: XOR<video_commentCreateInput, video_commentUncheckedCreateInput>
  }

  /**
   * video_comment createMany
   */
  export type video_commentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many video_comments.
     */
    data: video_commentCreateManyInput | video_commentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * video_comment update
   */
  export type video_commentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    /**
     * The data needed to update a video_comment.
     */
    data: XOR<video_commentUpdateInput, video_commentUncheckedUpdateInput>
    /**
     * Choose, which video_comment to update.
     */
    where: video_commentWhereUniqueInput
  }

  /**
   * video_comment updateMany
   */
  export type video_commentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update video_comments.
     */
    data: XOR<video_commentUpdateManyMutationInput, video_commentUncheckedUpdateManyInput>
    /**
     * Filter which video_comments to update
     */
    where?: video_commentWhereInput
  }

  /**
   * video_comment upsert
   */
  export type video_commentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    /**
     * The filter to search for the video_comment to update in case it exists.
     */
    where: video_commentWhereUniqueInput
    /**
     * In case the video_comment found by the `where` argument doesn't exist, create a new video_comment with this data.
     */
    create: XOR<video_commentCreateInput, video_commentUncheckedCreateInput>
    /**
     * In case the video_comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<video_commentUpdateInput, video_commentUncheckedUpdateInput>
  }

  /**
   * video_comment delete
   */
  export type video_commentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
    /**
     * Filter which video_comment to delete.
     */
    where: video_commentWhereUniqueInput
  }

  /**
   * video_comment deleteMany
   */
  export type video_commentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which video_comments to delete
     */
    where?: video_commentWhereInput
  }

  /**
   * video_comment.users
   */
  export type video_comment$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * video_comment.video
   */
  export type video_comment$videoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    where?: videoWhereInput
  }

  /**
   * video_comment without action
   */
  export type video_commentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_comment
     */
    select?: video_commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_commentInclude<ExtArgs> | null
  }


  /**
   * Model video_like
   */

  export type AggregateVideo_like = {
    _count: Video_likeCountAggregateOutputType | null
    _avg: Video_likeAvgAggregateOutputType | null
    _sum: Video_likeSumAggregateOutputType | null
    _min: Video_likeMinAggregateOutputType | null
    _max: Video_likeMaxAggregateOutputType | null
  }

  export type Video_likeAvgAggregateOutputType = {
    like_id: number | null
    user_id: number | null
    video_id: number | null
  }

  export type Video_likeSumAggregateOutputType = {
    like_id: number | null
    user_id: number | null
    video_id: number | null
  }

  export type Video_likeMinAggregateOutputType = {
    like_id: number | null
    user_id: number | null
    video_id: number | null
    date_create: Date | null
    dis_like: boolean | null
  }

  export type Video_likeMaxAggregateOutputType = {
    like_id: number | null
    user_id: number | null
    video_id: number | null
    date_create: Date | null
    dis_like: boolean | null
  }

  export type Video_likeCountAggregateOutputType = {
    like_id: number
    user_id: number
    video_id: number
    date_create: number
    dis_like: number
    _all: number
  }


  export type Video_likeAvgAggregateInputType = {
    like_id?: true
    user_id?: true
    video_id?: true
  }

  export type Video_likeSumAggregateInputType = {
    like_id?: true
    user_id?: true
    video_id?: true
  }

  export type Video_likeMinAggregateInputType = {
    like_id?: true
    user_id?: true
    video_id?: true
    date_create?: true
    dis_like?: true
  }

  export type Video_likeMaxAggregateInputType = {
    like_id?: true
    user_id?: true
    video_id?: true
    date_create?: true
    dis_like?: true
  }

  export type Video_likeCountAggregateInputType = {
    like_id?: true
    user_id?: true
    video_id?: true
    date_create?: true
    dis_like?: true
    _all?: true
  }

  export type Video_likeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which video_like to aggregate.
     */
    where?: video_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_likes to fetch.
     */
    orderBy?: video_likeOrderByWithRelationInput | video_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: video_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned video_likes
    **/
    _count?: true | Video_likeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Video_likeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Video_likeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Video_likeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Video_likeMaxAggregateInputType
  }

  export type GetVideo_likeAggregateType<T extends Video_likeAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo_like]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo_like[P]>
      : GetScalarType<T[P], AggregateVideo_like[P]>
  }




  export type video_likeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: video_likeWhereInput
    orderBy?: video_likeOrderByWithAggregationInput | video_likeOrderByWithAggregationInput[]
    by: Video_likeScalarFieldEnum[] | Video_likeScalarFieldEnum
    having?: video_likeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Video_likeCountAggregateInputType | true
    _avg?: Video_likeAvgAggregateInputType
    _sum?: Video_likeSumAggregateInputType
    _min?: Video_likeMinAggregateInputType
    _max?: Video_likeMaxAggregateInputType
  }

  export type Video_likeGroupByOutputType = {
    like_id: number
    user_id: number | null
    video_id: number | null
    date_create: Date | null
    dis_like: boolean | null
    _count: Video_likeCountAggregateOutputType | null
    _avg: Video_likeAvgAggregateOutputType | null
    _sum: Video_likeSumAggregateOutputType | null
    _min: Video_likeMinAggregateOutputType | null
    _max: Video_likeMaxAggregateOutputType | null
  }

  type GetVideo_likeGroupByPayload<T extends video_likeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Video_likeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Video_likeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Video_likeGroupByOutputType[P]>
            : GetScalarType<T[P], Video_likeGroupByOutputType[P]>
        }
      >
    >


  export type video_likeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    like_id?: boolean
    user_id?: boolean
    video_id?: boolean
    date_create?: boolean
    dis_like?: boolean
    users?: boolean | video_like$usersArgs<ExtArgs>
    video?: boolean | video_like$videoArgs<ExtArgs>
  }, ExtArgs["result"]["video_like"]>


  export type video_likeSelectScalar = {
    like_id?: boolean
    user_id?: boolean
    video_id?: boolean
    date_create?: boolean
    dis_like?: boolean
  }

  export type video_likeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | video_like$usersArgs<ExtArgs>
    video?: boolean | video_like$videoArgs<ExtArgs>
  }

  export type $video_likePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "video_like"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
      video: Prisma.$videoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      like_id: number
      user_id: number | null
      video_id: number | null
      date_create: Date | null
      dis_like: boolean | null
    }, ExtArgs["result"]["video_like"]>
    composites: {}
  }

  type video_likeGetPayload<S extends boolean | null | undefined | video_likeDefaultArgs> = $Result.GetResult<Prisma.$video_likePayload, S>

  type video_likeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<video_likeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Video_likeCountAggregateInputType | true
    }

  export interface video_likeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['video_like'], meta: { name: 'video_like' } }
    /**
     * Find zero or one Video_like that matches the filter.
     * @param {video_likeFindUniqueArgs} args - Arguments to find a Video_like
     * @example
     * // Get one Video_like
     * const video_like = await prisma.video_like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends video_likeFindUniqueArgs>(args: SelectSubset<T, video_likeFindUniqueArgs<ExtArgs>>): Prisma__video_likeClient<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Video_like that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {video_likeFindUniqueOrThrowArgs} args - Arguments to find a Video_like
     * @example
     * // Get one Video_like
     * const video_like = await prisma.video_like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends video_likeFindUniqueOrThrowArgs>(args: SelectSubset<T, video_likeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__video_likeClient<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Video_like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_likeFindFirstArgs} args - Arguments to find a Video_like
     * @example
     * // Get one Video_like
     * const video_like = await prisma.video_like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends video_likeFindFirstArgs>(args?: SelectSubset<T, video_likeFindFirstArgs<ExtArgs>>): Prisma__video_likeClient<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Video_like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_likeFindFirstOrThrowArgs} args - Arguments to find a Video_like
     * @example
     * // Get one Video_like
     * const video_like = await prisma.video_like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends video_likeFindFirstOrThrowArgs>(args?: SelectSubset<T, video_likeFindFirstOrThrowArgs<ExtArgs>>): Prisma__video_likeClient<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Video_likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_likeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Video_likes
     * const video_likes = await prisma.video_like.findMany()
     * 
     * // Get first 10 Video_likes
     * const video_likes = await prisma.video_like.findMany({ take: 10 })
     * 
     * // Only select the `like_id`
     * const video_likeWithLike_idOnly = await prisma.video_like.findMany({ select: { like_id: true } })
     * 
     */
    findMany<T extends video_likeFindManyArgs>(args?: SelectSubset<T, video_likeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Video_like.
     * @param {video_likeCreateArgs} args - Arguments to create a Video_like.
     * @example
     * // Create one Video_like
     * const Video_like = await prisma.video_like.create({
     *   data: {
     *     // ... data to create a Video_like
     *   }
     * })
     * 
     */
    create<T extends video_likeCreateArgs>(args: SelectSubset<T, video_likeCreateArgs<ExtArgs>>): Prisma__video_likeClient<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Video_likes.
     * @param {video_likeCreateManyArgs} args - Arguments to create many Video_likes.
     * @example
     * // Create many Video_likes
     * const video_like = await prisma.video_like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends video_likeCreateManyArgs>(args?: SelectSubset<T, video_likeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Video_like.
     * @param {video_likeDeleteArgs} args - Arguments to delete one Video_like.
     * @example
     * // Delete one Video_like
     * const Video_like = await prisma.video_like.delete({
     *   where: {
     *     // ... filter to delete one Video_like
     *   }
     * })
     * 
     */
    delete<T extends video_likeDeleteArgs>(args: SelectSubset<T, video_likeDeleteArgs<ExtArgs>>): Prisma__video_likeClient<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Video_like.
     * @param {video_likeUpdateArgs} args - Arguments to update one Video_like.
     * @example
     * // Update one Video_like
     * const video_like = await prisma.video_like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends video_likeUpdateArgs>(args: SelectSubset<T, video_likeUpdateArgs<ExtArgs>>): Prisma__video_likeClient<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Video_likes.
     * @param {video_likeDeleteManyArgs} args - Arguments to filter Video_likes to delete.
     * @example
     * // Delete a few Video_likes
     * const { count } = await prisma.video_like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends video_likeDeleteManyArgs>(args?: SelectSubset<T, video_likeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Video_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_likeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Video_likes
     * const video_like = await prisma.video_like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends video_likeUpdateManyArgs>(args: SelectSubset<T, video_likeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video_like.
     * @param {video_likeUpsertArgs} args - Arguments to update or create a Video_like.
     * @example
     * // Update or create a Video_like
     * const video_like = await prisma.video_like.upsert({
     *   create: {
     *     // ... data to create a Video_like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video_like we want to update
     *   }
     * })
     */
    upsert<T extends video_likeUpsertArgs>(args: SelectSubset<T, video_likeUpsertArgs<ExtArgs>>): Prisma__video_likeClient<$Result.GetResult<Prisma.$video_likePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Video_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_likeCountArgs} args - Arguments to filter Video_likes to count.
     * @example
     * // Count the number of Video_likes
     * const count = await prisma.video_like.count({
     *   where: {
     *     // ... the filter for the Video_likes we want to count
     *   }
     * })
    **/
    count<T extends video_likeCountArgs>(
      args?: Subset<T, video_likeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Video_likeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video_like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Video_likeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Video_likeAggregateArgs>(args: Subset<T, Video_likeAggregateArgs>): Prisma.PrismaPromise<GetVideo_likeAggregateType<T>>

    /**
     * Group by Video_like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_likeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends video_likeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: video_likeGroupByArgs['orderBy'] }
        : { orderBy?: video_likeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, video_likeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideo_likeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the video_like model
   */
  readonly fields: video_likeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for video_like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__video_likeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends video_like$usersArgs<ExtArgs> = {}>(args?: Subset<T, video_like$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    video<T extends video_like$videoArgs<ExtArgs> = {}>(args?: Subset<T, video_like$videoArgs<ExtArgs>>): Prisma__videoClient<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the video_like model
   */ 
  interface video_likeFieldRefs {
    readonly like_id: FieldRef<"video_like", 'Int'>
    readonly user_id: FieldRef<"video_like", 'Int'>
    readonly video_id: FieldRef<"video_like", 'Int'>
    readonly date_create: FieldRef<"video_like", 'DateTime'>
    readonly dis_like: FieldRef<"video_like", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * video_like findUnique
   */
  export type video_likeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    /**
     * Filter, which video_like to fetch.
     */
    where: video_likeWhereUniqueInput
  }

  /**
   * video_like findUniqueOrThrow
   */
  export type video_likeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    /**
     * Filter, which video_like to fetch.
     */
    where: video_likeWhereUniqueInput
  }

  /**
   * video_like findFirst
   */
  export type video_likeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    /**
     * Filter, which video_like to fetch.
     */
    where?: video_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_likes to fetch.
     */
    orderBy?: video_likeOrderByWithRelationInput | video_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for video_likes.
     */
    cursor?: video_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of video_likes.
     */
    distinct?: Video_likeScalarFieldEnum | Video_likeScalarFieldEnum[]
  }

  /**
   * video_like findFirstOrThrow
   */
  export type video_likeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    /**
     * Filter, which video_like to fetch.
     */
    where?: video_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_likes to fetch.
     */
    orderBy?: video_likeOrderByWithRelationInput | video_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for video_likes.
     */
    cursor?: video_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of video_likes.
     */
    distinct?: Video_likeScalarFieldEnum | Video_likeScalarFieldEnum[]
  }

  /**
   * video_like findMany
   */
  export type video_likeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    /**
     * Filter, which video_likes to fetch.
     */
    where?: video_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_likes to fetch.
     */
    orderBy?: video_likeOrderByWithRelationInput | video_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing video_likes.
     */
    cursor?: video_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_likes.
     */
    skip?: number
    distinct?: Video_likeScalarFieldEnum | Video_likeScalarFieldEnum[]
  }

  /**
   * video_like create
   */
  export type video_likeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    /**
     * The data needed to create a video_like.
     */
    data?: XOR<video_likeCreateInput, video_likeUncheckedCreateInput>
  }

  /**
   * video_like createMany
   */
  export type video_likeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many video_likes.
     */
    data: video_likeCreateManyInput | video_likeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * video_like update
   */
  export type video_likeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    /**
     * The data needed to update a video_like.
     */
    data: XOR<video_likeUpdateInput, video_likeUncheckedUpdateInput>
    /**
     * Choose, which video_like to update.
     */
    where: video_likeWhereUniqueInput
  }

  /**
   * video_like updateMany
   */
  export type video_likeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update video_likes.
     */
    data: XOR<video_likeUpdateManyMutationInput, video_likeUncheckedUpdateManyInput>
    /**
     * Filter which video_likes to update
     */
    where?: video_likeWhereInput
  }

  /**
   * video_like upsert
   */
  export type video_likeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    /**
     * The filter to search for the video_like to update in case it exists.
     */
    where: video_likeWhereUniqueInput
    /**
     * In case the video_like found by the `where` argument doesn't exist, create a new video_like with this data.
     */
    create: XOR<video_likeCreateInput, video_likeUncheckedCreateInput>
    /**
     * In case the video_like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<video_likeUpdateInput, video_likeUncheckedUpdateInput>
  }

  /**
   * video_like delete
   */
  export type video_likeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
    /**
     * Filter which video_like to delete.
     */
    where: video_likeWhereUniqueInput
  }

  /**
   * video_like deleteMany
   */
  export type video_likeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which video_likes to delete
     */
    where?: video_likeWhereInput
  }

  /**
   * video_like.users
   */
  export type video_like$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * video_like.video
   */
  export type video_like$videoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    where?: videoWhereInput
  }

  /**
   * video_like without action
   */
  export type video_likeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_like
     */
    select?: video_likeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_likeInclude<ExtArgs> | null
  }


  /**
   * Model video_type
   */

  export type AggregateVideo_type = {
    _count: Video_typeCountAggregateOutputType | null
    _avg: Video_typeAvgAggregateOutputType | null
    _sum: Video_typeSumAggregateOutputType | null
    _min: Video_typeMinAggregateOutputType | null
    _max: Video_typeMaxAggregateOutputType | null
  }

  export type Video_typeAvgAggregateOutputType = {
    type_id: number | null
  }

  export type Video_typeSumAggregateOutputType = {
    type_id: number | null
  }

  export type Video_typeMinAggregateOutputType = {
    type_id: number | null
    type_name: string | null
    icon: string | null
  }

  export type Video_typeMaxAggregateOutputType = {
    type_id: number | null
    type_name: string | null
    icon: string | null
  }

  export type Video_typeCountAggregateOutputType = {
    type_id: number
    type_name: number
    icon: number
    _all: number
  }


  export type Video_typeAvgAggregateInputType = {
    type_id?: true
  }

  export type Video_typeSumAggregateInputType = {
    type_id?: true
  }

  export type Video_typeMinAggregateInputType = {
    type_id?: true
    type_name?: true
    icon?: true
  }

  export type Video_typeMaxAggregateInputType = {
    type_id?: true
    type_name?: true
    icon?: true
  }

  export type Video_typeCountAggregateInputType = {
    type_id?: true
    type_name?: true
    icon?: true
    _all?: true
  }

  export type Video_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which video_type to aggregate.
     */
    where?: video_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_types to fetch.
     */
    orderBy?: video_typeOrderByWithRelationInput | video_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: video_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned video_types
    **/
    _count?: true | Video_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Video_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Video_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Video_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Video_typeMaxAggregateInputType
  }

  export type GetVideo_typeAggregateType<T extends Video_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo_type[P]>
      : GetScalarType<T[P], AggregateVideo_type[P]>
  }




  export type video_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: video_typeWhereInput
    orderBy?: video_typeOrderByWithAggregationInput | video_typeOrderByWithAggregationInput[]
    by: Video_typeScalarFieldEnum[] | Video_typeScalarFieldEnum
    having?: video_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Video_typeCountAggregateInputType | true
    _avg?: Video_typeAvgAggregateInputType
    _sum?: Video_typeSumAggregateInputType
    _min?: Video_typeMinAggregateInputType
    _max?: Video_typeMaxAggregateInputType
  }

  export type Video_typeGroupByOutputType = {
    type_id: number
    type_name: string | null
    icon: string | null
    _count: Video_typeCountAggregateOutputType | null
    _avg: Video_typeAvgAggregateOutputType | null
    _sum: Video_typeSumAggregateOutputType | null
    _min: Video_typeMinAggregateOutputType | null
    _max: Video_typeMaxAggregateOutputType | null
  }

  type GetVideo_typeGroupByPayload<T extends video_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Video_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Video_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Video_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Video_typeGroupByOutputType[P]>
        }
      >
    >


  export type video_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type_id?: boolean
    type_name?: boolean
    icon?: boolean
    video?: boolean | video_type$videoArgs<ExtArgs>
    _count?: boolean | Video_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video_type"]>


  export type video_typeSelectScalar = {
    type_id?: boolean
    type_name?: boolean
    icon?: boolean
  }

  export type video_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | video_type$videoArgs<ExtArgs>
    _count?: boolean | Video_typeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $video_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "video_type"
    objects: {
      video: Prisma.$videoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      type_id: number
      type_name: string | null
      icon: string | null
    }, ExtArgs["result"]["video_type"]>
    composites: {}
  }

  type video_typeGetPayload<S extends boolean | null | undefined | video_typeDefaultArgs> = $Result.GetResult<Prisma.$video_typePayload, S>

  type video_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<video_typeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Video_typeCountAggregateInputType | true
    }

  export interface video_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['video_type'], meta: { name: 'video_type' } }
    /**
     * Find zero or one Video_type that matches the filter.
     * @param {video_typeFindUniqueArgs} args - Arguments to find a Video_type
     * @example
     * // Get one Video_type
     * const video_type = await prisma.video_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends video_typeFindUniqueArgs>(args: SelectSubset<T, video_typeFindUniqueArgs<ExtArgs>>): Prisma__video_typeClient<$Result.GetResult<Prisma.$video_typePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Video_type that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {video_typeFindUniqueOrThrowArgs} args - Arguments to find a Video_type
     * @example
     * // Get one Video_type
     * const video_type = await prisma.video_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends video_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, video_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__video_typeClient<$Result.GetResult<Prisma.$video_typePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Video_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_typeFindFirstArgs} args - Arguments to find a Video_type
     * @example
     * // Get one Video_type
     * const video_type = await prisma.video_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends video_typeFindFirstArgs>(args?: SelectSubset<T, video_typeFindFirstArgs<ExtArgs>>): Prisma__video_typeClient<$Result.GetResult<Prisma.$video_typePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Video_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_typeFindFirstOrThrowArgs} args - Arguments to find a Video_type
     * @example
     * // Get one Video_type
     * const video_type = await prisma.video_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends video_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, video_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__video_typeClient<$Result.GetResult<Prisma.$video_typePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Video_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Video_types
     * const video_types = await prisma.video_type.findMany()
     * 
     * // Get first 10 Video_types
     * const video_types = await prisma.video_type.findMany({ take: 10 })
     * 
     * // Only select the `type_id`
     * const video_typeWithType_idOnly = await prisma.video_type.findMany({ select: { type_id: true } })
     * 
     */
    findMany<T extends video_typeFindManyArgs>(args?: SelectSubset<T, video_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$video_typePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Video_type.
     * @param {video_typeCreateArgs} args - Arguments to create a Video_type.
     * @example
     * // Create one Video_type
     * const Video_type = await prisma.video_type.create({
     *   data: {
     *     // ... data to create a Video_type
     *   }
     * })
     * 
     */
    create<T extends video_typeCreateArgs>(args: SelectSubset<T, video_typeCreateArgs<ExtArgs>>): Prisma__video_typeClient<$Result.GetResult<Prisma.$video_typePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Video_types.
     * @param {video_typeCreateManyArgs} args - Arguments to create many Video_types.
     * @example
     * // Create many Video_types
     * const video_type = await prisma.video_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends video_typeCreateManyArgs>(args?: SelectSubset<T, video_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Video_type.
     * @param {video_typeDeleteArgs} args - Arguments to delete one Video_type.
     * @example
     * // Delete one Video_type
     * const Video_type = await prisma.video_type.delete({
     *   where: {
     *     // ... filter to delete one Video_type
     *   }
     * })
     * 
     */
    delete<T extends video_typeDeleteArgs>(args: SelectSubset<T, video_typeDeleteArgs<ExtArgs>>): Prisma__video_typeClient<$Result.GetResult<Prisma.$video_typePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Video_type.
     * @param {video_typeUpdateArgs} args - Arguments to update one Video_type.
     * @example
     * // Update one Video_type
     * const video_type = await prisma.video_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends video_typeUpdateArgs>(args: SelectSubset<T, video_typeUpdateArgs<ExtArgs>>): Prisma__video_typeClient<$Result.GetResult<Prisma.$video_typePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Video_types.
     * @param {video_typeDeleteManyArgs} args - Arguments to filter Video_types to delete.
     * @example
     * // Delete a few Video_types
     * const { count } = await prisma.video_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends video_typeDeleteManyArgs>(args?: SelectSubset<T, video_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Video_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Video_types
     * const video_type = await prisma.video_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends video_typeUpdateManyArgs>(args: SelectSubset<T, video_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video_type.
     * @param {video_typeUpsertArgs} args - Arguments to update or create a Video_type.
     * @example
     * // Update or create a Video_type
     * const video_type = await prisma.video_type.upsert({
     *   create: {
     *     // ... data to create a Video_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video_type we want to update
     *   }
     * })
     */
    upsert<T extends video_typeUpsertArgs>(args: SelectSubset<T, video_typeUpsertArgs<ExtArgs>>): Prisma__video_typeClient<$Result.GetResult<Prisma.$video_typePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Video_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_typeCountArgs} args - Arguments to filter Video_types to count.
     * @example
     * // Count the number of Video_types
     * const count = await prisma.video_type.count({
     *   where: {
     *     // ... the filter for the Video_types we want to count
     *   }
     * })
    **/
    count<T extends video_typeCountArgs>(
      args?: Subset<T, video_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Video_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Video_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Video_typeAggregateArgs>(args: Subset<T, Video_typeAggregateArgs>): Prisma.PrismaPromise<GetVideo_typeAggregateType<T>>

    /**
     * Group by Video_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {video_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends video_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: video_typeGroupByArgs['orderBy'] }
        : { orderBy?: video_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, video_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideo_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the video_type model
   */
  readonly fields: video_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for video_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__video_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends video_type$videoArgs<ExtArgs> = {}>(args?: Subset<T, video_type$videoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the video_type model
   */ 
  interface video_typeFieldRefs {
    readonly type_id: FieldRef<"video_type", 'Int'>
    readonly type_name: FieldRef<"video_type", 'String'>
    readonly icon: FieldRef<"video_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * video_type findUnique
   */
  export type video_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
    /**
     * Filter, which video_type to fetch.
     */
    where: video_typeWhereUniqueInput
  }

  /**
   * video_type findUniqueOrThrow
   */
  export type video_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
    /**
     * Filter, which video_type to fetch.
     */
    where: video_typeWhereUniqueInput
  }

  /**
   * video_type findFirst
   */
  export type video_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
    /**
     * Filter, which video_type to fetch.
     */
    where?: video_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_types to fetch.
     */
    orderBy?: video_typeOrderByWithRelationInput | video_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for video_types.
     */
    cursor?: video_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of video_types.
     */
    distinct?: Video_typeScalarFieldEnum | Video_typeScalarFieldEnum[]
  }

  /**
   * video_type findFirstOrThrow
   */
  export type video_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
    /**
     * Filter, which video_type to fetch.
     */
    where?: video_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_types to fetch.
     */
    orderBy?: video_typeOrderByWithRelationInput | video_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for video_types.
     */
    cursor?: video_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of video_types.
     */
    distinct?: Video_typeScalarFieldEnum | Video_typeScalarFieldEnum[]
  }

  /**
   * video_type findMany
   */
  export type video_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
    /**
     * Filter, which video_types to fetch.
     */
    where?: video_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of video_types to fetch.
     */
    orderBy?: video_typeOrderByWithRelationInput | video_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing video_types.
     */
    cursor?: video_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` video_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` video_types.
     */
    skip?: number
    distinct?: Video_typeScalarFieldEnum | Video_typeScalarFieldEnum[]
  }

  /**
   * video_type create
   */
  export type video_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a video_type.
     */
    data?: XOR<video_typeCreateInput, video_typeUncheckedCreateInput>
  }

  /**
   * video_type createMany
   */
  export type video_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many video_types.
     */
    data: video_typeCreateManyInput | video_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * video_type update
   */
  export type video_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a video_type.
     */
    data: XOR<video_typeUpdateInput, video_typeUncheckedUpdateInput>
    /**
     * Choose, which video_type to update.
     */
    where: video_typeWhereUniqueInput
  }

  /**
   * video_type updateMany
   */
  export type video_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update video_types.
     */
    data: XOR<video_typeUpdateManyMutationInput, video_typeUncheckedUpdateManyInput>
    /**
     * Filter which video_types to update
     */
    where?: video_typeWhereInput
  }

  /**
   * video_type upsert
   */
  export type video_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the video_type to update in case it exists.
     */
    where: video_typeWhereUniqueInput
    /**
     * In case the video_type found by the `where` argument doesn't exist, create a new video_type with this data.
     */
    create: XOR<video_typeCreateInput, video_typeUncheckedCreateInput>
    /**
     * In case the video_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<video_typeUpdateInput, video_typeUncheckedUpdateInput>
  }

  /**
   * video_type delete
   */
  export type video_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
    /**
     * Filter which video_type to delete.
     */
    where: video_typeWhereUniqueInput
  }

  /**
   * video_type deleteMany
   */
  export type video_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which video_types to delete
     */
    where?: video_typeWhereInput
  }

  /**
   * video_type.video
   */
  export type video_type$videoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video
     */
    select?: videoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videoInclude<ExtArgs> | null
    where?: videoWhereInput
    orderBy?: videoOrderByWithRelationInput | videoOrderByWithRelationInput[]
    cursor?: videoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * video_type without action
   */
  export type video_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the video_type
     */
    select?: video_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: video_typeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ChatScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    content: 'content',
    room_id: 'room_id',
    date: 'date'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const CodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    expired: 'expired'
  };

  export type CodeScalarFieldEnum = (typeof CodeScalarFieldEnum)[keyof typeof CodeScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    permission_id: 'permission_id',
    permission_name: 'permission_name',
    description: 'description'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    role_id: 'role_id',
    role_name: 'role_name',
    list_permission: 'list_permission'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    user_id: 'user_id',
    full_name: 'full_name',
    email: 'email',
    avatar: 'avatar',
    pass_word: 'pass_word',
    face_app_id: 'face_app_id',
    role_id: 'role_id',
    refresh_token: 'refresh_token'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    video_id: 'video_id',
    video_name: 'video_name',
    thumbnail: 'thumbnail',
    description: 'description',
    views: 'views',
    source: 'source',
    user_id: 'user_id',
    type_id: 'type_id'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const Video_commentScalarFieldEnum: {
    comment_id: 'comment_id',
    user_id: 'user_id',
    video_id: 'video_id',
    date_create: 'date_create',
    content: 'content',
    reply_list: 'reply_list',
    timestamp: 'timestamp'
  };

  export type Video_commentScalarFieldEnum = (typeof Video_commentScalarFieldEnum)[keyof typeof Video_commentScalarFieldEnum]


  export const Video_likeScalarFieldEnum: {
    like_id: 'like_id',
    user_id: 'user_id',
    video_id: 'video_id',
    date_create: 'date_create',
    dis_like: 'dis_like'
  };

  export type Video_likeScalarFieldEnum = (typeof Video_likeScalarFieldEnum)[keyof typeof Video_likeScalarFieldEnum]


  export const Video_typeScalarFieldEnum: {
    type_id: 'type_id',
    type_name: 'type_name',
    icon: 'icon'
  };

  export type Video_typeScalarFieldEnum = (typeof Video_typeScalarFieldEnum)[keyof typeof Video_typeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type chatWhereInput = {
    AND?: chatWhereInput | chatWhereInput[]
    OR?: chatWhereInput[]
    NOT?: chatWhereInput | chatWhereInput[]
    id?: IntFilter<"chat"> | number
    user_id?: IntNullableFilter<"chat"> | number | null
    content?: StringNullableFilter<"chat"> | string | null
    room_id?: StringNullableFilter<"chat"> | string | null
    date?: DateTimeNullableFilter<"chat"> | Date | string | null
  }

  export type chatOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    room_id?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
  }

  export type chatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: chatWhereInput | chatWhereInput[]
    OR?: chatWhereInput[]
    NOT?: chatWhereInput | chatWhereInput[]
    user_id?: IntNullableFilter<"chat"> | number | null
    content?: StringNullableFilter<"chat"> | string | null
    room_id?: StringNullableFilter<"chat"> | string | null
    date?: DateTimeNullableFilter<"chat"> | Date | string | null
  }, "id">

  export type chatOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    room_id?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    _count?: chatCountOrderByAggregateInput
    _avg?: chatAvgOrderByAggregateInput
    _max?: chatMaxOrderByAggregateInput
    _min?: chatMinOrderByAggregateInput
    _sum?: chatSumOrderByAggregateInput
  }

  export type chatScalarWhereWithAggregatesInput = {
    AND?: chatScalarWhereWithAggregatesInput | chatScalarWhereWithAggregatesInput[]
    OR?: chatScalarWhereWithAggregatesInput[]
    NOT?: chatScalarWhereWithAggregatesInput | chatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chat"> | number
    user_id?: IntNullableWithAggregatesFilter<"chat"> | number | null
    content?: StringNullableWithAggregatesFilter<"chat"> | string | null
    room_id?: StringNullableWithAggregatesFilter<"chat"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"chat"> | Date | string | null
  }

  export type codeWhereInput = {
    AND?: codeWhereInput | codeWhereInput[]
    OR?: codeWhereInput[]
    NOT?: codeWhereInput | codeWhereInput[]
    id?: BigIntFilter<"code"> | bigint | number
    code?: StringNullableFilter<"code"> | string | null
    expired?: DateTimeNullableFilter<"code"> | Date | string | null
  }

  export type codeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    expired?: SortOrderInput | SortOrder
  }

  export type codeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: codeWhereInput | codeWhereInput[]
    OR?: codeWhereInput[]
    NOT?: codeWhereInput | codeWhereInput[]
    code?: StringNullableFilter<"code"> | string | null
    expired?: DateTimeNullableFilter<"code"> | Date | string | null
  }, "id" | "id">

  export type codeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    expired?: SortOrderInput | SortOrder
    _count?: codeCountOrderByAggregateInput
    _avg?: codeAvgOrderByAggregateInput
    _max?: codeMaxOrderByAggregateInput
    _min?: codeMinOrderByAggregateInput
    _sum?: codeSumOrderByAggregateInput
  }

  export type codeScalarWhereWithAggregatesInput = {
    AND?: codeScalarWhereWithAggregatesInput | codeScalarWhereWithAggregatesInput[]
    OR?: codeScalarWhereWithAggregatesInput[]
    NOT?: codeScalarWhereWithAggregatesInput | codeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"code"> | bigint | number
    code?: StringNullableWithAggregatesFilter<"code"> | string | null
    expired?: DateTimeNullableWithAggregatesFilter<"code"> | Date | string | null
  }

  export type permissionWhereInput = {
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    permission_id?: IntFilter<"permission"> | number
    permission_name?: StringNullableFilter<"permission"> | string | null
    description?: StringNullableFilter<"permission"> | string | null
  }

  export type permissionOrderByWithRelationInput = {
    permission_id?: SortOrder
    permission_name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type permissionWhereUniqueInput = Prisma.AtLeast<{
    permission_id?: number
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    permission_name?: StringNullableFilter<"permission"> | string | null
    description?: StringNullableFilter<"permission"> | string | null
  }, "permission_id">

  export type permissionOrderByWithAggregationInput = {
    permission_id?: SortOrder
    permission_name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: permissionCountOrderByAggregateInput
    _avg?: permissionAvgOrderByAggregateInput
    _max?: permissionMaxOrderByAggregateInput
    _min?: permissionMinOrderByAggregateInput
    _sum?: permissionSumOrderByAggregateInput
  }

  export type permissionScalarWhereWithAggregatesInput = {
    AND?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    OR?: permissionScalarWhereWithAggregatesInput[]
    NOT?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    permission_id?: IntWithAggregatesFilter<"permission"> | number
    permission_name?: StringNullableWithAggregatesFilter<"permission"> | string | null
    description?: StringNullableWithAggregatesFilter<"permission"> | string | null
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    role_id?: IntFilter<"role"> | number
    role_name?: StringNullableFilter<"role"> | string | null
    list_permission?: StringNullableFilter<"role"> | string | null
    users?: UsersListRelationFilter
  }

  export type roleOrderByWithRelationInput = {
    role_id?: SortOrder
    role_name?: SortOrderInput | SortOrder
    list_permission?: SortOrderInput | SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    role_id?: number
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    role_name?: StringNullableFilter<"role"> | string | null
    list_permission?: StringNullableFilter<"role"> | string | null
    users?: UsersListRelationFilter
  }, "role_id">

  export type roleOrderByWithAggregationInput = {
    role_id?: SortOrder
    role_name?: SortOrderInput | SortOrder
    list_permission?: SortOrderInput | SortOrder
    _count?: roleCountOrderByAggregateInput
    _avg?: roleAvgOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
    _sum?: roleSumOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"role"> | number
    role_name?: StringNullableWithAggregatesFilter<"role"> | string | null
    list_permission?: StringNullableWithAggregatesFilter<"role"> | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    user_id?: IntFilter<"users"> | number
    full_name?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    avatar?: StringNullableFilter<"users"> | string | null
    pass_word?: StringNullableFilter<"users"> | string | null
    face_app_id?: StringNullableFilter<"users"> | string | null
    role_id?: IntNullableFilter<"users"> | number | null
    refresh_token?: StringNullableFilter<"users"> | string | null
    role?: XOR<RoleNullableRelationFilter, roleWhereInput> | null
    video?: VideoListRelationFilter
    video_comment?: Video_commentListRelationFilter
    video_like?: Video_likeListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    user_id?: SortOrder
    full_name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    pass_word?: SortOrderInput | SortOrder
    face_app_id?: SortOrderInput | SortOrder
    role_id?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    role?: roleOrderByWithRelationInput
    video?: videoOrderByRelationAggregateInput
    video_comment?: video_commentOrderByRelationAggregateInput
    video_like?: video_likeOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    full_name?: StringNullableFilter<"users"> | string | null
    avatar?: StringNullableFilter<"users"> | string | null
    pass_word?: StringNullableFilter<"users"> | string | null
    face_app_id?: StringNullableFilter<"users"> | string | null
    role_id?: IntNullableFilter<"users"> | number | null
    refresh_token?: StringNullableFilter<"users"> | string | null
    role?: XOR<RoleNullableRelationFilter, roleWhereInput> | null
    video?: VideoListRelationFilter
    video_comment?: Video_commentListRelationFilter
    video_like?: Video_likeListRelationFilter
  }, "user_id" | "email">

  export type usersOrderByWithAggregationInput = {
    user_id?: SortOrder
    full_name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    pass_word?: SortOrderInput | SortOrder
    face_app_id?: SortOrderInput | SortOrder
    role_id?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"users"> | number
    full_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    email?: StringNullableWithAggregatesFilter<"users"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"users"> | string | null
    pass_word?: StringNullableWithAggregatesFilter<"users"> | string | null
    face_app_id?: StringNullableWithAggregatesFilter<"users"> | string | null
    role_id?: IntNullableWithAggregatesFilter<"users"> | number | null
    refresh_token?: StringNullableWithAggregatesFilter<"users"> | string | null
  }

  export type videoWhereInput = {
    AND?: videoWhereInput | videoWhereInput[]
    OR?: videoWhereInput[]
    NOT?: videoWhereInput | videoWhereInput[]
    video_id?: IntFilter<"video"> | number
    video_name?: StringNullableFilter<"video"> | string | null
    thumbnail?: StringNullableFilter<"video"> | string | null
    description?: StringNullableFilter<"video"> | string | null
    views?: IntNullableFilter<"video"> | number | null
    source?: StringNullableFilter<"video"> | string | null
    user_id?: IntNullableFilter<"video"> | number | null
    type_id?: IntNullableFilter<"video"> | number | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    video_type?: XOR<Video_typeNullableRelationFilter, video_typeWhereInput> | null
    video_comment?: Video_commentListRelationFilter
    video_like?: Video_likeListRelationFilter
  }

  export type videoOrderByWithRelationInput = {
    video_id?: SortOrder
    video_name?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    views?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    type_id?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    video_type?: video_typeOrderByWithRelationInput
    video_comment?: video_commentOrderByRelationAggregateInput
    video_like?: video_likeOrderByRelationAggregateInput
  }

  export type videoWhereUniqueInput = Prisma.AtLeast<{
    video_id?: number
    AND?: videoWhereInput | videoWhereInput[]
    OR?: videoWhereInput[]
    NOT?: videoWhereInput | videoWhereInput[]
    video_name?: StringNullableFilter<"video"> | string | null
    thumbnail?: StringNullableFilter<"video"> | string | null
    description?: StringNullableFilter<"video"> | string | null
    views?: IntNullableFilter<"video"> | number | null
    source?: StringNullableFilter<"video"> | string | null
    user_id?: IntNullableFilter<"video"> | number | null
    type_id?: IntNullableFilter<"video"> | number | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    video_type?: XOR<Video_typeNullableRelationFilter, video_typeWhereInput> | null
    video_comment?: Video_commentListRelationFilter
    video_like?: Video_likeListRelationFilter
  }, "video_id">

  export type videoOrderByWithAggregationInput = {
    video_id?: SortOrder
    video_name?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    views?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    type_id?: SortOrderInput | SortOrder
    _count?: videoCountOrderByAggregateInput
    _avg?: videoAvgOrderByAggregateInput
    _max?: videoMaxOrderByAggregateInput
    _min?: videoMinOrderByAggregateInput
    _sum?: videoSumOrderByAggregateInput
  }

  export type videoScalarWhereWithAggregatesInput = {
    AND?: videoScalarWhereWithAggregatesInput | videoScalarWhereWithAggregatesInput[]
    OR?: videoScalarWhereWithAggregatesInput[]
    NOT?: videoScalarWhereWithAggregatesInput | videoScalarWhereWithAggregatesInput[]
    video_id?: IntWithAggregatesFilter<"video"> | number
    video_name?: StringNullableWithAggregatesFilter<"video"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"video"> | string | null
    description?: StringNullableWithAggregatesFilter<"video"> | string | null
    views?: IntNullableWithAggregatesFilter<"video"> | number | null
    source?: StringNullableWithAggregatesFilter<"video"> | string | null
    user_id?: IntNullableWithAggregatesFilter<"video"> | number | null
    type_id?: IntNullableWithAggregatesFilter<"video"> | number | null
  }

  export type video_commentWhereInput = {
    AND?: video_commentWhereInput | video_commentWhereInput[]
    OR?: video_commentWhereInput[]
    NOT?: video_commentWhereInput | video_commentWhereInput[]
    comment_id?: IntFilter<"video_comment"> | number
    user_id?: IntNullableFilter<"video_comment"> | number | null
    video_id?: IntNullableFilter<"video_comment"> | number | null
    date_create?: DateTimeNullableFilter<"video_comment"> | Date | string | null
    content?: StringNullableFilter<"video_comment"> | string | null
    reply_list?: StringNullableFilter<"video_comment"> | string | null
    timestamp?: DateTimeNullableFilter<"video_comment"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    video?: XOR<VideoNullableRelationFilter, videoWhereInput> | null
  }

  export type video_commentOrderByWithRelationInput = {
    comment_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    video_id?: SortOrderInput | SortOrder
    date_create?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    reply_list?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    video?: videoOrderByWithRelationInput
  }

  export type video_commentWhereUniqueInput = Prisma.AtLeast<{
    comment_id?: number
    AND?: video_commentWhereInput | video_commentWhereInput[]
    OR?: video_commentWhereInput[]
    NOT?: video_commentWhereInput | video_commentWhereInput[]
    user_id?: IntNullableFilter<"video_comment"> | number | null
    video_id?: IntNullableFilter<"video_comment"> | number | null
    date_create?: DateTimeNullableFilter<"video_comment"> | Date | string | null
    content?: StringNullableFilter<"video_comment"> | string | null
    reply_list?: StringNullableFilter<"video_comment"> | string | null
    timestamp?: DateTimeNullableFilter<"video_comment"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    video?: XOR<VideoNullableRelationFilter, videoWhereInput> | null
  }, "comment_id">

  export type video_commentOrderByWithAggregationInput = {
    comment_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    video_id?: SortOrderInput | SortOrder
    date_create?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    reply_list?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    _count?: video_commentCountOrderByAggregateInput
    _avg?: video_commentAvgOrderByAggregateInput
    _max?: video_commentMaxOrderByAggregateInput
    _min?: video_commentMinOrderByAggregateInput
    _sum?: video_commentSumOrderByAggregateInput
  }

  export type video_commentScalarWhereWithAggregatesInput = {
    AND?: video_commentScalarWhereWithAggregatesInput | video_commentScalarWhereWithAggregatesInput[]
    OR?: video_commentScalarWhereWithAggregatesInput[]
    NOT?: video_commentScalarWhereWithAggregatesInput | video_commentScalarWhereWithAggregatesInput[]
    comment_id?: IntWithAggregatesFilter<"video_comment"> | number
    user_id?: IntNullableWithAggregatesFilter<"video_comment"> | number | null
    video_id?: IntNullableWithAggregatesFilter<"video_comment"> | number | null
    date_create?: DateTimeNullableWithAggregatesFilter<"video_comment"> | Date | string | null
    content?: StringNullableWithAggregatesFilter<"video_comment"> | string | null
    reply_list?: StringNullableWithAggregatesFilter<"video_comment"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"video_comment"> | Date | string | null
  }

  export type video_likeWhereInput = {
    AND?: video_likeWhereInput | video_likeWhereInput[]
    OR?: video_likeWhereInput[]
    NOT?: video_likeWhereInput | video_likeWhereInput[]
    like_id?: IntFilter<"video_like"> | number
    user_id?: IntNullableFilter<"video_like"> | number | null
    video_id?: IntNullableFilter<"video_like"> | number | null
    date_create?: DateTimeNullableFilter<"video_like"> | Date | string | null
    dis_like?: BoolNullableFilter<"video_like"> | boolean | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    video?: XOR<VideoNullableRelationFilter, videoWhereInput> | null
  }

  export type video_likeOrderByWithRelationInput = {
    like_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    video_id?: SortOrderInput | SortOrder
    date_create?: SortOrderInput | SortOrder
    dis_like?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    video?: videoOrderByWithRelationInput
  }

  export type video_likeWhereUniqueInput = Prisma.AtLeast<{
    like_id?: number
    AND?: video_likeWhereInput | video_likeWhereInput[]
    OR?: video_likeWhereInput[]
    NOT?: video_likeWhereInput | video_likeWhereInput[]
    user_id?: IntNullableFilter<"video_like"> | number | null
    video_id?: IntNullableFilter<"video_like"> | number | null
    date_create?: DateTimeNullableFilter<"video_like"> | Date | string | null
    dis_like?: BoolNullableFilter<"video_like"> | boolean | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    video?: XOR<VideoNullableRelationFilter, videoWhereInput> | null
  }, "like_id">

  export type video_likeOrderByWithAggregationInput = {
    like_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    video_id?: SortOrderInput | SortOrder
    date_create?: SortOrderInput | SortOrder
    dis_like?: SortOrderInput | SortOrder
    _count?: video_likeCountOrderByAggregateInput
    _avg?: video_likeAvgOrderByAggregateInput
    _max?: video_likeMaxOrderByAggregateInput
    _min?: video_likeMinOrderByAggregateInput
    _sum?: video_likeSumOrderByAggregateInput
  }

  export type video_likeScalarWhereWithAggregatesInput = {
    AND?: video_likeScalarWhereWithAggregatesInput | video_likeScalarWhereWithAggregatesInput[]
    OR?: video_likeScalarWhereWithAggregatesInput[]
    NOT?: video_likeScalarWhereWithAggregatesInput | video_likeScalarWhereWithAggregatesInput[]
    like_id?: IntWithAggregatesFilter<"video_like"> | number
    user_id?: IntNullableWithAggregatesFilter<"video_like"> | number | null
    video_id?: IntNullableWithAggregatesFilter<"video_like"> | number | null
    date_create?: DateTimeNullableWithAggregatesFilter<"video_like"> | Date | string | null
    dis_like?: BoolNullableWithAggregatesFilter<"video_like"> | boolean | null
  }

  export type video_typeWhereInput = {
    AND?: video_typeWhereInput | video_typeWhereInput[]
    OR?: video_typeWhereInput[]
    NOT?: video_typeWhereInput | video_typeWhereInput[]
    type_id?: IntFilter<"video_type"> | number
    type_name?: StringNullableFilter<"video_type"> | string | null
    icon?: StringNullableFilter<"video_type"> | string | null
    video?: VideoListRelationFilter
  }

  export type video_typeOrderByWithRelationInput = {
    type_id?: SortOrder
    type_name?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    video?: videoOrderByRelationAggregateInput
  }

  export type video_typeWhereUniqueInput = Prisma.AtLeast<{
    type_id?: number
    AND?: video_typeWhereInput | video_typeWhereInput[]
    OR?: video_typeWhereInput[]
    NOT?: video_typeWhereInput | video_typeWhereInput[]
    type_name?: StringNullableFilter<"video_type"> | string | null
    icon?: StringNullableFilter<"video_type"> | string | null
    video?: VideoListRelationFilter
  }, "type_id">

  export type video_typeOrderByWithAggregationInput = {
    type_id?: SortOrder
    type_name?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    _count?: video_typeCountOrderByAggregateInput
    _avg?: video_typeAvgOrderByAggregateInput
    _max?: video_typeMaxOrderByAggregateInput
    _min?: video_typeMinOrderByAggregateInput
    _sum?: video_typeSumOrderByAggregateInput
  }

  export type video_typeScalarWhereWithAggregatesInput = {
    AND?: video_typeScalarWhereWithAggregatesInput | video_typeScalarWhereWithAggregatesInput[]
    OR?: video_typeScalarWhereWithAggregatesInput[]
    NOT?: video_typeScalarWhereWithAggregatesInput | video_typeScalarWhereWithAggregatesInput[]
    type_id?: IntWithAggregatesFilter<"video_type"> | number
    type_name?: StringNullableWithAggregatesFilter<"video_type"> | string | null
    icon?: StringNullableWithAggregatesFilter<"video_type"> | string | null
  }

  export type chatCreateInput = {
    user_id?: number | null
    content?: string | null
    room_id?: string | null
    date?: Date | string | null
  }

  export type chatUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    content?: string | null
    room_id?: string | null
    date?: Date | string | null
  }

  export type chatUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatCreateManyInput = {
    id?: number
    user_id?: number | null
    content?: string | null
    room_id?: string | null
    date?: Date | string | null
  }

  export type chatUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type codeCreateInput = {
    id?: bigint | number
    code?: string | null
    expired?: Date | string | null
  }

  export type codeUncheckedCreateInput = {
    id?: bigint | number
    code?: string | null
    expired?: Date | string | null
  }

  export type codeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    expired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type codeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    expired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type codeCreateManyInput = {
    id?: bigint | number
    code?: string | null
    expired?: Date | string | null
  }

  export type codeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    expired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type codeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    expired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionCreateInput = {
    permission_name?: string | null
    description?: string | null
  }

  export type permissionUncheckedCreateInput = {
    permission_id?: number
    permission_name?: string | null
    description?: string | null
  }

  export type permissionUpdateInput = {
    permission_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionUncheckedUpdateInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    permission_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionCreateManyInput = {
    permission_id?: number
    permission_name?: string | null
    description?: string | null
  }

  export type permissionUpdateManyMutationInput = {
    permission_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionUncheckedUpdateManyInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    permission_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleCreateInput = {
    role_name?: string | null
    list_permission?: string | null
    users?: usersCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateInput = {
    role_id?: number
    role_name?: string | null
    list_permission?: string | null
    users?: usersUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleUpdateInput = {
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    list_permission?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    list_permission?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleCreateManyInput = {
    role_id?: number
    role_name?: string | null
    list_permission?: string | null
  }

  export type roleUpdateManyMutationInput = {
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    list_permission?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    list_permission?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersCreateInput = {
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    refresh_token?: string | null
    role?: roleCreateNestedOneWithoutUsersInput
    video?: videoCreateNestedManyWithoutUsersInput
    video_comment?: video_commentCreateNestedManyWithoutUsersInput
    video_like?: video_likeCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    user_id?: number
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    role_id?: number | null
    refresh_token?: string | null
    video?: videoUncheckedCreateNestedManyWithoutUsersInput
    video_comment?: video_commentUncheckedCreateNestedManyWithoutUsersInput
    video_like?: video_likeUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    role?: roleUpdateOneWithoutUsersNestedInput
    video?: videoUpdateManyWithoutUsersNestedInput
    video_comment?: video_commentUpdateManyWithoutUsersNestedInput
    video_like?: video_likeUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableIntFieldUpdateOperationsInput | number | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    video?: videoUncheckedUpdateManyWithoutUsersNestedInput
    video_comment?: video_commentUncheckedUpdateManyWithoutUsersNestedInput
    video_like?: video_likeUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    user_id?: number
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    role_id?: number | null
    refresh_token?: string | null
  }

  export type usersUpdateManyMutationInput = {
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableIntFieldUpdateOperationsInput | number | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type videoCreateInput = {
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    users?: usersCreateNestedOneWithoutVideoInput
    video_type?: video_typeCreateNestedOneWithoutVideoInput
    video_comment?: video_commentCreateNestedManyWithoutVideoInput
    video_like?: video_likeCreateNestedManyWithoutVideoInput
  }

  export type videoUncheckedCreateInput = {
    video_id?: number
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    user_id?: number | null
    type_id?: number | null
    video_comment?: video_commentUncheckedCreateNestedManyWithoutVideoInput
    video_like?: video_likeUncheckedCreateNestedManyWithoutVideoInput
  }

  export type videoUpdateInput = {
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneWithoutVideoNestedInput
    video_type?: video_typeUpdateOneWithoutVideoNestedInput
    video_comment?: video_commentUpdateManyWithoutVideoNestedInput
    video_like?: video_likeUpdateManyWithoutVideoNestedInput
  }

  export type videoUncheckedUpdateInput = {
    video_id?: IntFieldUpdateOperationsInput | number
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_comment?: video_commentUncheckedUpdateManyWithoutVideoNestedInput
    video_like?: video_likeUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type videoCreateManyInput = {
    video_id?: number
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    user_id?: number | null
    type_id?: number | null
  }

  export type videoUpdateManyMutationInput = {
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type videoUncheckedUpdateManyInput = {
    video_id?: IntFieldUpdateOperationsInput | number
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type video_commentCreateInput = {
    date_create?: Date | string | null
    content?: string | null
    reply_list?: string | null
    timestamp?: Date | string | null
    users?: usersCreateNestedOneWithoutVideo_commentInput
    video?: videoCreateNestedOneWithoutVideo_commentInput
  }

  export type video_commentUncheckedCreateInput = {
    comment_id?: number
    user_id?: number | null
    video_id?: number | null
    date_create?: Date | string | null
    content?: string | null
    reply_list?: string | null
    timestamp?: Date | string | null
  }

  export type video_commentUpdateInput = {
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reply_list?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutVideo_commentNestedInput
    video?: videoUpdateOneWithoutVideo_commentNestedInput
  }

  export type video_commentUncheckedUpdateInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reply_list?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type video_commentCreateManyInput = {
    comment_id?: number
    user_id?: number | null
    video_id?: number | null
    date_create?: Date | string | null
    content?: string | null
    reply_list?: string | null
    timestamp?: Date | string | null
  }

  export type video_commentUpdateManyMutationInput = {
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reply_list?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type video_commentUncheckedUpdateManyInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reply_list?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type video_likeCreateInput = {
    date_create?: Date | string | null
    dis_like?: boolean | null
    users?: usersCreateNestedOneWithoutVideo_likeInput
    video?: videoCreateNestedOneWithoutVideo_likeInput
  }

  export type video_likeUncheckedCreateInput = {
    like_id?: number
    user_id?: number | null
    video_id?: number | null
    date_create?: Date | string | null
    dis_like?: boolean | null
  }

  export type video_likeUpdateInput = {
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dis_like?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: usersUpdateOneWithoutVideo_likeNestedInput
    video?: videoUpdateOneWithoutVideo_likeNestedInput
  }

  export type video_likeUncheckedUpdateInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dis_like?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type video_likeCreateManyInput = {
    like_id?: number
    user_id?: number | null
    video_id?: number | null
    date_create?: Date | string | null
    dis_like?: boolean | null
  }

  export type video_likeUpdateManyMutationInput = {
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dis_like?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type video_likeUncheckedUpdateManyInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dis_like?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type video_typeCreateInput = {
    type_name?: string | null
    icon?: string | null
    video?: videoCreateNestedManyWithoutVideo_typeInput
  }

  export type video_typeUncheckedCreateInput = {
    type_id?: number
    type_name?: string | null
    icon?: string | null
    video?: videoUncheckedCreateNestedManyWithoutVideo_typeInput
  }

  export type video_typeUpdateInput = {
    type_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    video?: videoUpdateManyWithoutVideo_typeNestedInput
  }

  export type video_typeUncheckedUpdateInput = {
    type_id?: IntFieldUpdateOperationsInput | number
    type_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    video?: videoUncheckedUpdateManyWithoutVideo_typeNestedInput
  }

  export type video_typeCreateManyInput = {
    type_id?: number
    type_name?: string | null
    icon?: string | null
  }

  export type video_typeUpdateManyMutationInput = {
    type_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type video_typeUncheckedUpdateManyInput = {
    type_id?: IntFieldUpdateOperationsInput | number
    type_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type chatCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    room_id?: SortOrder
    date?: SortOrder
  }

  export type chatAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type chatMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    room_id?: SortOrder
    date?: SortOrder
  }

  export type chatMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    room_id?: SortOrder
    date?: SortOrder
  }

  export type chatSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type codeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expired?: SortOrder
  }

  export type codeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type codeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expired?: SortOrder
  }

  export type codeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expired?: SortOrder
  }

  export type codeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type permissionCountOrderByAggregateInput = {
    permission_id?: SortOrder
    permission_name?: SortOrder
    description?: SortOrder
  }

  export type permissionAvgOrderByAggregateInput = {
    permission_id?: SortOrder
  }

  export type permissionMaxOrderByAggregateInput = {
    permission_id?: SortOrder
    permission_name?: SortOrder
    description?: SortOrder
  }

  export type permissionMinOrderByAggregateInput = {
    permission_id?: SortOrder
    permission_name?: SortOrder
    description?: SortOrder
  }

  export type permissionSumOrderByAggregateInput = {
    permission_id?: SortOrder
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roleCountOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    list_permission?: SortOrder
  }

  export type roleAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    list_permission?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    list_permission?: SortOrder
  }

  export type roleSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type RoleNullableRelationFilter = {
    is?: roleWhereInput | null
    isNot?: roleWhereInput | null
  }

  export type VideoListRelationFilter = {
    every?: videoWhereInput
    some?: videoWhereInput
    none?: videoWhereInput
  }

  export type Video_commentListRelationFilter = {
    every?: video_commentWhereInput
    some?: video_commentWhereInput
    none?: video_commentWhereInput
  }

  export type Video_likeListRelationFilter = {
    every?: video_likeWhereInput
    some?: video_likeWhereInput
    none?: video_likeWhereInput
  }

  export type videoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type video_commentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type video_likeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    pass_word?: SortOrder
    face_app_id?: SortOrder
    role_id?: SortOrder
    refresh_token?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    pass_word?: SortOrder
    face_app_id?: SortOrder
    role_id?: SortOrder
    refresh_token?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    pass_word?: SortOrder
    face_app_id?: SortOrder
    role_id?: SortOrder
    refresh_token?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type Video_typeNullableRelationFilter = {
    is?: video_typeWhereInput | null
    isNot?: video_typeWhereInput | null
  }

  export type videoCountOrderByAggregateInput = {
    video_id?: SortOrder
    video_name?: SortOrder
    thumbnail?: SortOrder
    description?: SortOrder
    views?: SortOrder
    source?: SortOrder
    user_id?: SortOrder
    type_id?: SortOrder
  }

  export type videoAvgOrderByAggregateInput = {
    video_id?: SortOrder
    views?: SortOrder
    user_id?: SortOrder
    type_id?: SortOrder
  }

  export type videoMaxOrderByAggregateInput = {
    video_id?: SortOrder
    video_name?: SortOrder
    thumbnail?: SortOrder
    description?: SortOrder
    views?: SortOrder
    source?: SortOrder
    user_id?: SortOrder
    type_id?: SortOrder
  }

  export type videoMinOrderByAggregateInput = {
    video_id?: SortOrder
    video_name?: SortOrder
    thumbnail?: SortOrder
    description?: SortOrder
    views?: SortOrder
    source?: SortOrder
    user_id?: SortOrder
    type_id?: SortOrder
  }

  export type videoSumOrderByAggregateInput = {
    video_id?: SortOrder
    views?: SortOrder
    user_id?: SortOrder
    type_id?: SortOrder
  }

  export type VideoNullableRelationFilter = {
    is?: videoWhereInput | null
    isNot?: videoWhereInput | null
  }

  export type video_commentCountOrderByAggregateInput = {
    comment_id?: SortOrder
    user_id?: SortOrder
    video_id?: SortOrder
    date_create?: SortOrder
    content?: SortOrder
    reply_list?: SortOrder
    timestamp?: SortOrder
  }

  export type video_commentAvgOrderByAggregateInput = {
    comment_id?: SortOrder
    user_id?: SortOrder
    video_id?: SortOrder
  }

  export type video_commentMaxOrderByAggregateInput = {
    comment_id?: SortOrder
    user_id?: SortOrder
    video_id?: SortOrder
    date_create?: SortOrder
    content?: SortOrder
    reply_list?: SortOrder
    timestamp?: SortOrder
  }

  export type video_commentMinOrderByAggregateInput = {
    comment_id?: SortOrder
    user_id?: SortOrder
    video_id?: SortOrder
    date_create?: SortOrder
    content?: SortOrder
    reply_list?: SortOrder
    timestamp?: SortOrder
  }

  export type video_commentSumOrderByAggregateInput = {
    comment_id?: SortOrder
    user_id?: SortOrder
    video_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type video_likeCountOrderByAggregateInput = {
    like_id?: SortOrder
    user_id?: SortOrder
    video_id?: SortOrder
    date_create?: SortOrder
    dis_like?: SortOrder
  }

  export type video_likeAvgOrderByAggregateInput = {
    like_id?: SortOrder
    user_id?: SortOrder
    video_id?: SortOrder
  }

  export type video_likeMaxOrderByAggregateInput = {
    like_id?: SortOrder
    user_id?: SortOrder
    video_id?: SortOrder
    date_create?: SortOrder
    dis_like?: SortOrder
  }

  export type video_likeMinOrderByAggregateInput = {
    like_id?: SortOrder
    user_id?: SortOrder
    video_id?: SortOrder
    date_create?: SortOrder
    dis_like?: SortOrder
  }

  export type video_likeSumOrderByAggregateInput = {
    like_id?: SortOrder
    user_id?: SortOrder
    video_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type video_typeCountOrderByAggregateInput = {
    type_id?: SortOrder
    type_name?: SortOrder
    icon?: SortOrder
  }

  export type video_typeAvgOrderByAggregateInput = {
    type_id?: SortOrder
  }

  export type video_typeMaxOrderByAggregateInput = {
    type_id?: SortOrder
    type_name?: SortOrder
    icon?: SortOrder
  }

  export type video_typeMinOrderByAggregateInput = {
    type_id?: SortOrder
    type_name?: SortOrder
    icon?: SortOrder
  }

  export type video_typeSumOrderByAggregateInput = {
    type_id?: SortOrder
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type usersCreateNestedManyWithoutRoleInput = {
    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]
    createMany?: usersCreateManyRoleInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]
    createMany?: usersCreateManyRoleInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUpdateManyWithoutRoleNestedInput = {
    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutRoleInput | usersUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: usersCreateManyRoleInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutRoleInput | usersUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: usersUpdateManyWithWhereWithoutRoleInput | usersUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutRoleInput | usersUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: usersCreateManyRoleInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutRoleInput | usersUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: usersUpdateManyWithWhereWithoutRoleInput | usersUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type roleCreateNestedOneWithoutUsersInput = {
    create?: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: roleCreateOrConnectWithoutUsersInput
    connect?: roleWhereUniqueInput
  }

  export type videoCreateNestedManyWithoutUsersInput = {
    create?: XOR<videoCreateWithoutUsersInput, videoUncheckedCreateWithoutUsersInput> | videoCreateWithoutUsersInput[] | videoUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: videoCreateOrConnectWithoutUsersInput | videoCreateOrConnectWithoutUsersInput[]
    createMany?: videoCreateManyUsersInputEnvelope
    connect?: videoWhereUniqueInput | videoWhereUniqueInput[]
  }

  export type video_commentCreateNestedManyWithoutUsersInput = {
    create?: XOR<video_commentCreateWithoutUsersInput, video_commentUncheckedCreateWithoutUsersInput> | video_commentCreateWithoutUsersInput[] | video_commentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: video_commentCreateOrConnectWithoutUsersInput | video_commentCreateOrConnectWithoutUsersInput[]
    createMany?: video_commentCreateManyUsersInputEnvelope
    connect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
  }

  export type video_likeCreateNestedManyWithoutUsersInput = {
    create?: XOR<video_likeCreateWithoutUsersInput, video_likeUncheckedCreateWithoutUsersInput> | video_likeCreateWithoutUsersInput[] | video_likeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: video_likeCreateOrConnectWithoutUsersInput | video_likeCreateOrConnectWithoutUsersInput[]
    createMany?: video_likeCreateManyUsersInputEnvelope
    connect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
  }

  export type videoUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<videoCreateWithoutUsersInput, videoUncheckedCreateWithoutUsersInput> | videoCreateWithoutUsersInput[] | videoUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: videoCreateOrConnectWithoutUsersInput | videoCreateOrConnectWithoutUsersInput[]
    createMany?: videoCreateManyUsersInputEnvelope
    connect?: videoWhereUniqueInput | videoWhereUniqueInput[]
  }

  export type video_commentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<video_commentCreateWithoutUsersInput, video_commentUncheckedCreateWithoutUsersInput> | video_commentCreateWithoutUsersInput[] | video_commentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: video_commentCreateOrConnectWithoutUsersInput | video_commentCreateOrConnectWithoutUsersInput[]
    createMany?: video_commentCreateManyUsersInputEnvelope
    connect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
  }

  export type video_likeUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<video_likeCreateWithoutUsersInput, video_likeUncheckedCreateWithoutUsersInput> | video_likeCreateWithoutUsersInput[] | video_likeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: video_likeCreateOrConnectWithoutUsersInput | video_likeCreateOrConnectWithoutUsersInput[]
    createMany?: video_likeCreateManyUsersInputEnvelope
    connect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
  }

  export type roleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: roleCreateOrConnectWithoutUsersInput
    upsert?: roleUpsertWithoutUsersInput
    disconnect?: roleWhereInput | boolean
    delete?: roleWhereInput | boolean
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutUsersInput, roleUpdateWithoutUsersInput>, roleUncheckedUpdateWithoutUsersInput>
  }

  export type videoUpdateManyWithoutUsersNestedInput = {
    create?: XOR<videoCreateWithoutUsersInput, videoUncheckedCreateWithoutUsersInput> | videoCreateWithoutUsersInput[] | videoUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: videoCreateOrConnectWithoutUsersInput | videoCreateOrConnectWithoutUsersInput[]
    upsert?: videoUpsertWithWhereUniqueWithoutUsersInput | videoUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: videoCreateManyUsersInputEnvelope
    set?: videoWhereUniqueInput | videoWhereUniqueInput[]
    disconnect?: videoWhereUniqueInput | videoWhereUniqueInput[]
    delete?: videoWhereUniqueInput | videoWhereUniqueInput[]
    connect?: videoWhereUniqueInput | videoWhereUniqueInput[]
    update?: videoUpdateWithWhereUniqueWithoutUsersInput | videoUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: videoUpdateManyWithWhereWithoutUsersInput | videoUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: videoScalarWhereInput | videoScalarWhereInput[]
  }

  export type video_commentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<video_commentCreateWithoutUsersInput, video_commentUncheckedCreateWithoutUsersInput> | video_commentCreateWithoutUsersInput[] | video_commentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: video_commentCreateOrConnectWithoutUsersInput | video_commentCreateOrConnectWithoutUsersInput[]
    upsert?: video_commentUpsertWithWhereUniqueWithoutUsersInput | video_commentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: video_commentCreateManyUsersInputEnvelope
    set?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    disconnect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    delete?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    connect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    update?: video_commentUpdateWithWhereUniqueWithoutUsersInput | video_commentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: video_commentUpdateManyWithWhereWithoutUsersInput | video_commentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: video_commentScalarWhereInput | video_commentScalarWhereInput[]
  }

  export type video_likeUpdateManyWithoutUsersNestedInput = {
    create?: XOR<video_likeCreateWithoutUsersInput, video_likeUncheckedCreateWithoutUsersInput> | video_likeCreateWithoutUsersInput[] | video_likeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: video_likeCreateOrConnectWithoutUsersInput | video_likeCreateOrConnectWithoutUsersInput[]
    upsert?: video_likeUpsertWithWhereUniqueWithoutUsersInput | video_likeUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: video_likeCreateManyUsersInputEnvelope
    set?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    disconnect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    delete?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    connect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    update?: video_likeUpdateWithWhereUniqueWithoutUsersInput | video_likeUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: video_likeUpdateManyWithWhereWithoutUsersInput | video_likeUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: video_likeScalarWhereInput | video_likeScalarWhereInput[]
  }

  export type videoUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<videoCreateWithoutUsersInput, videoUncheckedCreateWithoutUsersInput> | videoCreateWithoutUsersInput[] | videoUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: videoCreateOrConnectWithoutUsersInput | videoCreateOrConnectWithoutUsersInput[]
    upsert?: videoUpsertWithWhereUniqueWithoutUsersInput | videoUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: videoCreateManyUsersInputEnvelope
    set?: videoWhereUniqueInput | videoWhereUniqueInput[]
    disconnect?: videoWhereUniqueInput | videoWhereUniqueInput[]
    delete?: videoWhereUniqueInput | videoWhereUniqueInput[]
    connect?: videoWhereUniqueInput | videoWhereUniqueInput[]
    update?: videoUpdateWithWhereUniqueWithoutUsersInput | videoUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: videoUpdateManyWithWhereWithoutUsersInput | videoUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: videoScalarWhereInput | videoScalarWhereInput[]
  }

  export type video_commentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<video_commentCreateWithoutUsersInput, video_commentUncheckedCreateWithoutUsersInput> | video_commentCreateWithoutUsersInput[] | video_commentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: video_commentCreateOrConnectWithoutUsersInput | video_commentCreateOrConnectWithoutUsersInput[]
    upsert?: video_commentUpsertWithWhereUniqueWithoutUsersInput | video_commentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: video_commentCreateManyUsersInputEnvelope
    set?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    disconnect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    delete?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    connect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    update?: video_commentUpdateWithWhereUniqueWithoutUsersInput | video_commentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: video_commentUpdateManyWithWhereWithoutUsersInput | video_commentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: video_commentScalarWhereInput | video_commentScalarWhereInput[]
  }

  export type video_likeUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<video_likeCreateWithoutUsersInput, video_likeUncheckedCreateWithoutUsersInput> | video_likeCreateWithoutUsersInput[] | video_likeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: video_likeCreateOrConnectWithoutUsersInput | video_likeCreateOrConnectWithoutUsersInput[]
    upsert?: video_likeUpsertWithWhereUniqueWithoutUsersInput | video_likeUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: video_likeCreateManyUsersInputEnvelope
    set?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    disconnect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    delete?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    connect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    update?: video_likeUpdateWithWhereUniqueWithoutUsersInput | video_likeUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: video_likeUpdateManyWithWhereWithoutUsersInput | video_likeUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: video_likeScalarWhereInput | video_likeScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutVideoInput = {
    create?: XOR<usersCreateWithoutVideoInput, usersUncheckedCreateWithoutVideoInput>
    connectOrCreate?: usersCreateOrConnectWithoutVideoInput
    connect?: usersWhereUniqueInput
  }

  export type video_typeCreateNestedOneWithoutVideoInput = {
    create?: XOR<video_typeCreateWithoutVideoInput, video_typeUncheckedCreateWithoutVideoInput>
    connectOrCreate?: video_typeCreateOrConnectWithoutVideoInput
    connect?: video_typeWhereUniqueInput
  }

  export type video_commentCreateNestedManyWithoutVideoInput = {
    create?: XOR<video_commentCreateWithoutVideoInput, video_commentUncheckedCreateWithoutVideoInput> | video_commentCreateWithoutVideoInput[] | video_commentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: video_commentCreateOrConnectWithoutVideoInput | video_commentCreateOrConnectWithoutVideoInput[]
    createMany?: video_commentCreateManyVideoInputEnvelope
    connect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
  }

  export type video_likeCreateNestedManyWithoutVideoInput = {
    create?: XOR<video_likeCreateWithoutVideoInput, video_likeUncheckedCreateWithoutVideoInput> | video_likeCreateWithoutVideoInput[] | video_likeUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: video_likeCreateOrConnectWithoutVideoInput | video_likeCreateOrConnectWithoutVideoInput[]
    createMany?: video_likeCreateManyVideoInputEnvelope
    connect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
  }

  export type video_commentUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<video_commentCreateWithoutVideoInput, video_commentUncheckedCreateWithoutVideoInput> | video_commentCreateWithoutVideoInput[] | video_commentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: video_commentCreateOrConnectWithoutVideoInput | video_commentCreateOrConnectWithoutVideoInput[]
    createMany?: video_commentCreateManyVideoInputEnvelope
    connect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
  }

  export type video_likeUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<video_likeCreateWithoutVideoInput, video_likeUncheckedCreateWithoutVideoInput> | video_likeCreateWithoutVideoInput[] | video_likeUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: video_likeCreateOrConnectWithoutVideoInput | video_likeCreateOrConnectWithoutVideoInput[]
    createMany?: video_likeCreateManyVideoInputEnvelope
    connect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
  }

  export type usersUpdateOneWithoutVideoNestedInput = {
    create?: XOR<usersCreateWithoutVideoInput, usersUncheckedCreateWithoutVideoInput>
    connectOrCreate?: usersCreateOrConnectWithoutVideoInput
    upsert?: usersUpsertWithoutVideoInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutVideoInput, usersUpdateWithoutVideoInput>, usersUncheckedUpdateWithoutVideoInput>
  }

  export type video_typeUpdateOneWithoutVideoNestedInput = {
    create?: XOR<video_typeCreateWithoutVideoInput, video_typeUncheckedCreateWithoutVideoInput>
    connectOrCreate?: video_typeCreateOrConnectWithoutVideoInput
    upsert?: video_typeUpsertWithoutVideoInput
    disconnect?: video_typeWhereInput | boolean
    delete?: video_typeWhereInput | boolean
    connect?: video_typeWhereUniqueInput
    update?: XOR<XOR<video_typeUpdateToOneWithWhereWithoutVideoInput, video_typeUpdateWithoutVideoInput>, video_typeUncheckedUpdateWithoutVideoInput>
  }

  export type video_commentUpdateManyWithoutVideoNestedInput = {
    create?: XOR<video_commentCreateWithoutVideoInput, video_commentUncheckedCreateWithoutVideoInput> | video_commentCreateWithoutVideoInput[] | video_commentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: video_commentCreateOrConnectWithoutVideoInput | video_commentCreateOrConnectWithoutVideoInput[]
    upsert?: video_commentUpsertWithWhereUniqueWithoutVideoInput | video_commentUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: video_commentCreateManyVideoInputEnvelope
    set?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    disconnect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    delete?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    connect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    update?: video_commentUpdateWithWhereUniqueWithoutVideoInput | video_commentUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: video_commentUpdateManyWithWhereWithoutVideoInput | video_commentUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: video_commentScalarWhereInput | video_commentScalarWhereInput[]
  }

  export type video_likeUpdateManyWithoutVideoNestedInput = {
    create?: XOR<video_likeCreateWithoutVideoInput, video_likeUncheckedCreateWithoutVideoInput> | video_likeCreateWithoutVideoInput[] | video_likeUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: video_likeCreateOrConnectWithoutVideoInput | video_likeCreateOrConnectWithoutVideoInput[]
    upsert?: video_likeUpsertWithWhereUniqueWithoutVideoInput | video_likeUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: video_likeCreateManyVideoInputEnvelope
    set?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    disconnect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    delete?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    connect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    update?: video_likeUpdateWithWhereUniqueWithoutVideoInput | video_likeUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: video_likeUpdateManyWithWhereWithoutVideoInput | video_likeUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: video_likeScalarWhereInput | video_likeScalarWhereInput[]
  }

  export type video_commentUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<video_commentCreateWithoutVideoInput, video_commentUncheckedCreateWithoutVideoInput> | video_commentCreateWithoutVideoInput[] | video_commentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: video_commentCreateOrConnectWithoutVideoInput | video_commentCreateOrConnectWithoutVideoInput[]
    upsert?: video_commentUpsertWithWhereUniqueWithoutVideoInput | video_commentUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: video_commentCreateManyVideoInputEnvelope
    set?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    disconnect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    delete?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    connect?: video_commentWhereUniqueInput | video_commentWhereUniqueInput[]
    update?: video_commentUpdateWithWhereUniqueWithoutVideoInput | video_commentUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: video_commentUpdateManyWithWhereWithoutVideoInput | video_commentUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: video_commentScalarWhereInput | video_commentScalarWhereInput[]
  }

  export type video_likeUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<video_likeCreateWithoutVideoInput, video_likeUncheckedCreateWithoutVideoInput> | video_likeCreateWithoutVideoInput[] | video_likeUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: video_likeCreateOrConnectWithoutVideoInput | video_likeCreateOrConnectWithoutVideoInput[]
    upsert?: video_likeUpsertWithWhereUniqueWithoutVideoInput | video_likeUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: video_likeCreateManyVideoInputEnvelope
    set?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    disconnect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    delete?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    connect?: video_likeWhereUniqueInput | video_likeWhereUniqueInput[]
    update?: video_likeUpdateWithWhereUniqueWithoutVideoInput | video_likeUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: video_likeUpdateManyWithWhereWithoutVideoInput | video_likeUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: video_likeScalarWhereInput | video_likeScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutVideo_commentInput = {
    create?: XOR<usersCreateWithoutVideo_commentInput, usersUncheckedCreateWithoutVideo_commentInput>
    connectOrCreate?: usersCreateOrConnectWithoutVideo_commentInput
    connect?: usersWhereUniqueInput
  }

  export type videoCreateNestedOneWithoutVideo_commentInput = {
    create?: XOR<videoCreateWithoutVideo_commentInput, videoUncheckedCreateWithoutVideo_commentInput>
    connectOrCreate?: videoCreateOrConnectWithoutVideo_commentInput
    connect?: videoWhereUniqueInput
  }

  export type usersUpdateOneWithoutVideo_commentNestedInput = {
    create?: XOR<usersCreateWithoutVideo_commentInput, usersUncheckedCreateWithoutVideo_commentInput>
    connectOrCreate?: usersCreateOrConnectWithoutVideo_commentInput
    upsert?: usersUpsertWithoutVideo_commentInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutVideo_commentInput, usersUpdateWithoutVideo_commentInput>, usersUncheckedUpdateWithoutVideo_commentInput>
  }

  export type videoUpdateOneWithoutVideo_commentNestedInput = {
    create?: XOR<videoCreateWithoutVideo_commentInput, videoUncheckedCreateWithoutVideo_commentInput>
    connectOrCreate?: videoCreateOrConnectWithoutVideo_commentInput
    upsert?: videoUpsertWithoutVideo_commentInput
    disconnect?: videoWhereInput | boolean
    delete?: videoWhereInput | boolean
    connect?: videoWhereUniqueInput
    update?: XOR<XOR<videoUpdateToOneWithWhereWithoutVideo_commentInput, videoUpdateWithoutVideo_commentInput>, videoUncheckedUpdateWithoutVideo_commentInput>
  }

  export type usersCreateNestedOneWithoutVideo_likeInput = {
    create?: XOR<usersCreateWithoutVideo_likeInput, usersUncheckedCreateWithoutVideo_likeInput>
    connectOrCreate?: usersCreateOrConnectWithoutVideo_likeInput
    connect?: usersWhereUniqueInput
  }

  export type videoCreateNestedOneWithoutVideo_likeInput = {
    create?: XOR<videoCreateWithoutVideo_likeInput, videoUncheckedCreateWithoutVideo_likeInput>
    connectOrCreate?: videoCreateOrConnectWithoutVideo_likeInput
    connect?: videoWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type usersUpdateOneWithoutVideo_likeNestedInput = {
    create?: XOR<usersCreateWithoutVideo_likeInput, usersUncheckedCreateWithoutVideo_likeInput>
    connectOrCreate?: usersCreateOrConnectWithoutVideo_likeInput
    upsert?: usersUpsertWithoutVideo_likeInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutVideo_likeInput, usersUpdateWithoutVideo_likeInput>, usersUncheckedUpdateWithoutVideo_likeInput>
  }

  export type videoUpdateOneWithoutVideo_likeNestedInput = {
    create?: XOR<videoCreateWithoutVideo_likeInput, videoUncheckedCreateWithoutVideo_likeInput>
    connectOrCreate?: videoCreateOrConnectWithoutVideo_likeInput
    upsert?: videoUpsertWithoutVideo_likeInput
    disconnect?: videoWhereInput | boolean
    delete?: videoWhereInput | boolean
    connect?: videoWhereUniqueInput
    update?: XOR<XOR<videoUpdateToOneWithWhereWithoutVideo_likeInput, videoUpdateWithoutVideo_likeInput>, videoUncheckedUpdateWithoutVideo_likeInput>
  }

  export type videoCreateNestedManyWithoutVideo_typeInput = {
    create?: XOR<videoCreateWithoutVideo_typeInput, videoUncheckedCreateWithoutVideo_typeInput> | videoCreateWithoutVideo_typeInput[] | videoUncheckedCreateWithoutVideo_typeInput[]
    connectOrCreate?: videoCreateOrConnectWithoutVideo_typeInput | videoCreateOrConnectWithoutVideo_typeInput[]
    createMany?: videoCreateManyVideo_typeInputEnvelope
    connect?: videoWhereUniqueInput | videoWhereUniqueInput[]
  }

  export type videoUncheckedCreateNestedManyWithoutVideo_typeInput = {
    create?: XOR<videoCreateWithoutVideo_typeInput, videoUncheckedCreateWithoutVideo_typeInput> | videoCreateWithoutVideo_typeInput[] | videoUncheckedCreateWithoutVideo_typeInput[]
    connectOrCreate?: videoCreateOrConnectWithoutVideo_typeInput | videoCreateOrConnectWithoutVideo_typeInput[]
    createMany?: videoCreateManyVideo_typeInputEnvelope
    connect?: videoWhereUniqueInput | videoWhereUniqueInput[]
  }

  export type videoUpdateManyWithoutVideo_typeNestedInput = {
    create?: XOR<videoCreateWithoutVideo_typeInput, videoUncheckedCreateWithoutVideo_typeInput> | videoCreateWithoutVideo_typeInput[] | videoUncheckedCreateWithoutVideo_typeInput[]
    connectOrCreate?: videoCreateOrConnectWithoutVideo_typeInput | videoCreateOrConnectWithoutVideo_typeInput[]
    upsert?: videoUpsertWithWhereUniqueWithoutVideo_typeInput | videoUpsertWithWhereUniqueWithoutVideo_typeInput[]
    createMany?: videoCreateManyVideo_typeInputEnvelope
    set?: videoWhereUniqueInput | videoWhereUniqueInput[]
    disconnect?: videoWhereUniqueInput | videoWhereUniqueInput[]
    delete?: videoWhereUniqueInput | videoWhereUniqueInput[]
    connect?: videoWhereUniqueInput | videoWhereUniqueInput[]
    update?: videoUpdateWithWhereUniqueWithoutVideo_typeInput | videoUpdateWithWhereUniqueWithoutVideo_typeInput[]
    updateMany?: videoUpdateManyWithWhereWithoutVideo_typeInput | videoUpdateManyWithWhereWithoutVideo_typeInput[]
    deleteMany?: videoScalarWhereInput | videoScalarWhereInput[]
  }

  export type videoUncheckedUpdateManyWithoutVideo_typeNestedInput = {
    create?: XOR<videoCreateWithoutVideo_typeInput, videoUncheckedCreateWithoutVideo_typeInput> | videoCreateWithoutVideo_typeInput[] | videoUncheckedCreateWithoutVideo_typeInput[]
    connectOrCreate?: videoCreateOrConnectWithoutVideo_typeInput | videoCreateOrConnectWithoutVideo_typeInput[]
    upsert?: videoUpsertWithWhereUniqueWithoutVideo_typeInput | videoUpsertWithWhereUniqueWithoutVideo_typeInput[]
    createMany?: videoCreateManyVideo_typeInputEnvelope
    set?: videoWhereUniqueInput | videoWhereUniqueInput[]
    disconnect?: videoWhereUniqueInput | videoWhereUniqueInput[]
    delete?: videoWhereUniqueInput | videoWhereUniqueInput[]
    connect?: videoWhereUniqueInput | videoWhereUniqueInput[]
    update?: videoUpdateWithWhereUniqueWithoutVideo_typeInput | videoUpdateWithWhereUniqueWithoutVideo_typeInput[]
    updateMany?: videoUpdateManyWithWhereWithoutVideo_typeInput | videoUpdateManyWithWhereWithoutVideo_typeInput[]
    deleteMany?: videoScalarWhereInput | videoScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type usersCreateWithoutRoleInput = {
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    refresh_token?: string | null
    video?: videoCreateNestedManyWithoutUsersInput
    video_comment?: video_commentCreateNestedManyWithoutUsersInput
    video_like?: video_likeCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutRoleInput = {
    user_id?: number
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    refresh_token?: string | null
    video?: videoUncheckedCreateNestedManyWithoutUsersInput
    video_comment?: video_commentUncheckedCreateNestedManyWithoutUsersInput
    video_like?: video_likeUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutRoleInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput>
  }

  export type usersCreateManyRoleInputEnvelope = {
    data: usersCreateManyRoleInput | usersCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutRoleInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutRoleInput, usersUncheckedUpdateWithoutRoleInput>
    create: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput>
  }

  export type usersUpdateWithWhereUniqueWithoutRoleInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutRoleInput, usersUncheckedUpdateWithoutRoleInput>
  }

  export type usersUpdateManyWithWhereWithoutRoleInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutRoleInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    user_id?: IntFilter<"users"> | number
    full_name?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    avatar?: StringNullableFilter<"users"> | string | null
    pass_word?: StringNullableFilter<"users"> | string | null
    face_app_id?: StringNullableFilter<"users"> | string | null
    role_id?: IntNullableFilter<"users"> | number | null
    refresh_token?: StringNullableFilter<"users"> | string | null
  }

  export type roleCreateWithoutUsersInput = {
    role_name?: string | null
    list_permission?: string | null
  }

  export type roleUncheckedCreateWithoutUsersInput = {
    role_id?: number
    role_name?: string | null
    list_permission?: string | null
  }

  export type roleCreateOrConnectWithoutUsersInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
  }

  export type videoCreateWithoutUsersInput = {
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    video_type?: video_typeCreateNestedOneWithoutVideoInput
    video_comment?: video_commentCreateNestedManyWithoutVideoInput
    video_like?: video_likeCreateNestedManyWithoutVideoInput
  }

  export type videoUncheckedCreateWithoutUsersInput = {
    video_id?: number
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    type_id?: number | null
    video_comment?: video_commentUncheckedCreateNestedManyWithoutVideoInput
    video_like?: video_likeUncheckedCreateNestedManyWithoutVideoInput
  }

  export type videoCreateOrConnectWithoutUsersInput = {
    where: videoWhereUniqueInput
    create: XOR<videoCreateWithoutUsersInput, videoUncheckedCreateWithoutUsersInput>
  }

  export type videoCreateManyUsersInputEnvelope = {
    data: videoCreateManyUsersInput | videoCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type video_commentCreateWithoutUsersInput = {
    date_create?: Date | string | null
    content?: string | null
    reply_list?: string | null
    timestamp?: Date | string | null
    video?: videoCreateNestedOneWithoutVideo_commentInput
  }

  export type video_commentUncheckedCreateWithoutUsersInput = {
    comment_id?: number
    video_id?: number | null
    date_create?: Date | string | null
    content?: string | null
    reply_list?: string | null
    timestamp?: Date | string | null
  }

  export type video_commentCreateOrConnectWithoutUsersInput = {
    where: video_commentWhereUniqueInput
    create: XOR<video_commentCreateWithoutUsersInput, video_commentUncheckedCreateWithoutUsersInput>
  }

  export type video_commentCreateManyUsersInputEnvelope = {
    data: video_commentCreateManyUsersInput | video_commentCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type video_likeCreateWithoutUsersInput = {
    date_create?: Date | string | null
    dis_like?: boolean | null
    video?: videoCreateNestedOneWithoutVideo_likeInput
  }

  export type video_likeUncheckedCreateWithoutUsersInput = {
    like_id?: number
    video_id?: number | null
    date_create?: Date | string | null
    dis_like?: boolean | null
  }

  export type video_likeCreateOrConnectWithoutUsersInput = {
    where: video_likeWhereUniqueInput
    create: XOR<video_likeCreateWithoutUsersInput, video_likeUncheckedCreateWithoutUsersInput>
  }

  export type video_likeCreateManyUsersInputEnvelope = {
    data: video_likeCreateManyUsersInput | video_likeCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type roleUpsertWithoutUsersInput = {
    update: XOR<roleUpdateWithoutUsersInput, roleUncheckedUpdateWithoutUsersInput>
    create: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutUsersInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutUsersInput, roleUncheckedUpdateWithoutUsersInput>
  }

  export type roleUpdateWithoutUsersInput = {
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    list_permission?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUncheckedUpdateWithoutUsersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    list_permission?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type videoUpsertWithWhereUniqueWithoutUsersInput = {
    where: videoWhereUniqueInput
    update: XOR<videoUpdateWithoutUsersInput, videoUncheckedUpdateWithoutUsersInput>
    create: XOR<videoCreateWithoutUsersInput, videoUncheckedCreateWithoutUsersInput>
  }

  export type videoUpdateWithWhereUniqueWithoutUsersInput = {
    where: videoWhereUniqueInput
    data: XOR<videoUpdateWithoutUsersInput, videoUncheckedUpdateWithoutUsersInput>
  }

  export type videoUpdateManyWithWhereWithoutUsersInput = {
    where: videoScalarWhereInput
    data: XOR<videoUpdateManyMutationInput, videoUncheckedUpdateManyWithoutUsersInput>
  }

  export type videoScalarWhereInput = {
    AND?: videoScalarWhereInput | videoScalarWhereInput[]
    OR?: videoScalarWhereInput[]
    NOT?: videoScalarWhereInput | videoScalarWhereInput[]
    video_id?: IntFilter<"video"> | number
    video_name?: StringNullableFilter<"video"> | string | null
    thumbnail?: StringNullableFilter<"video"> | string | null
    description?: StringNullableFilter<"video"> | string | null
    views?: IntNullableFilter<"video"> | number | null
    source?: StringNullableFilter<"video"> | string | null
    user_id?: IntNullableFilter<"video"> | number | null
    type_id?: IntNullableFilter<"video"> | number | null
  }

  export type video_commentUpsertWithWhereUniqueWithoutUsersInput = {
    where: video_commentWhereUniqueInput
    update: XOR<video_commentUpdateWithoutUsersInput, video_commentUncheckedUpdateWithoutUsersInput>
    create: XOR<video_commentCreateWithoutUsersInput, video_commentUncheckedCreateWithoutUsersInput>
  }

  export type video_commentUpdateWithWhereUniqueWithoutUsersInput = {
    where: video_commentWhereUniqueInput
    data: XOR<video_commentUpdateWithoutUsersInput, video_commentUncheckedUpdateWithoutUsersInput>
  }

  export type video_commentUpdateManyWithWhereWithoutUsersInput = {
    where: video_commentScalarWhereInput
    data: XOR<video_commentUpdateManyMutationInput, video_commentUncheckedUpdateManyWithoutUsersInput>
  }

  export type video_commentScalarWhereInput = {
    AND?: video_commentScalarWhereInput | video_commentScalarWhereInput[]
    OR?: video_commentScalarWhereInput[]
    NOT?: video_commentScalarWhereInput | video_commentScalarWhereInput[]
    comment_id?: IntFilter<"video_comment"> | number
    user_id?: IntNullableFilter<"video_comment"> | number | null
    video_id?: IntNullableFilter<"video_comment"> | number | null
    date_create?: DateTimeNullableFilter<"video_comment"> | Date | string | null
    content?: StringNullableFilter<"video_comment"> | string | null
    reply_list?: StringNullableFilter<"video_comment"> | string | null
    timestamp?: DateTimeNullableFilter<"video_comment"> | Date | string | null
  }

  export type video_likeUpsertWithWhereUniqueWithoutUsersInput = {
    where: video_likeWhereUniqueInput
    update: XOR<video_likeUpdateWithoutUsersInput, video_likeUncheckedUpdateWithoutUsersInput>
    create: XOR<video_likeCreateWithoutUsersInput, video_likeUncheckedCreateWithoutUsersInput>
  }

  export type video_likeUpdateWithWhereUniqueWithoutUsersInput = {
    where: video_likeWhereUniqueInput
    data: XOR<video_likeUpdateWithoutUsersInput, video_likeUncheckedUpdateWithoutUsersInput>
  }

  export type video_likeUpdateManyWithWhereWithoutUsersInput = {
    where: video_likeScalarWhereInput
    data: XOR<video_likeUpdateManyMutationInput, video_likeUncheckedUpdateManyWithoutUsersInput>
  }

  export type video_likeScalarWhereInput = {
    AND?: video_likeScalarWhereInput | video_likeScalarWhereInput[]
    OR?: video_likeScalarWhereInput[]
    NOT?: video_likeScalarWhereInput | video_likeScalarWhereInput[]
    like_id?: IntFilter<"video_like"> | number
    user_id?: IntNullableFilter<"video_like"> | number | null
    video_id?: IntNullableFilter<"video_like"> | number | null
    date_create?: DateTimeNullableFilter<"video_like"> | Date | string | null
    dis_like?: BoolNullableFilter<"video_like"> | boolean | null
  }

  export type usersCreateWithoutVideoInput = {
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    refresh_token?: string | null
    role?: roleCreateNestedOneWithoutUsersInput
    video_comment?: video_commentCreateNestedManyWithoutUsersInput
    video_like?: video_likeCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVideoInput = {
    user_id?: number
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    role_id?: number | null
    refresh_token?: string | null
    video_comment?: video_commentUncheckedCreateNestedManyWithoutUsersInput
    video_like?: video_likeUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutVideoInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVideoInput, usersUncheckedCreateWithoutVideoInput>
  }

  export type video_typeCreateWithoutVideoInput = {
    type_name?: string | null
    icon?: string | null
  }

  export type video_typeUncheckedCreateWithoutVideoInput = {
    type_id?: number
    type_name?: string | null
    icon?: string | null
  }

  export type video_typeCreateOrConnectWithoutVideoInput = {
    where: video_typeWhereUniqueInput
    create: XOR<video_typeCreateWithoutVideoInput, video_typeUncheckedCreateWithoutVideoInput>
  }

  export type video_commentCreateWithoutVideoInput = {
    date_create?: Date | string | null
    content?: string | null
    reply_list?: string | null
    timestamp?: Date | string | null
    users?: usersCreateNestedOneWithoutVideo_commentInput
  }

  export type video_commentUncheckedCreateWithoutVideoInput = {
    comment_id?: number
    user_id?: number | null
    date_create?: Date | string | null
    content?: string | null
    reply_list?: string | null
    timestamp?: Date | string | null
  }

  export type video_commentCreateOrConnectWithoutVideoInput = {
    where: video_commentWhereUniqueInput
    create: XOR<video_commentCreateWithoutVideoInput, video_commentUncheckedCreateWithoutVideoInput>
  }

  export type video_commentCreateManyVideoInputEnvelope = {
    data: video_commentCreateManyVideoInput | video_commentCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type video_likeCreateWithoutVideoInput = {
    date_create?: Date | string | null
    dis_like?: boolean | null
    users?: usersCreateNestedOneWithoutVideo_likeInput
  }

  export type video_likeUncheckedCreateWithoutVideoInput = {
    like_id?: number
    user_id?: number | null
    date_create?: Date | string | null
    dis_like?: boolean | null
  }

  export type video_likeCreateOrConnectWithoutVideoInput = {
    where: video_likeWhereUniqueInput
    create: XOR<video_likeCreateWithoutVideoInput, video_likeUncheckedCreateWithoutVideoInput>
  }

  export type video_likeCreateManyVideoInputEnvelope = {
    data: video_likeCreateManyVideoInput | video_likeCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutVideoInput = {
    update: XOR<usersUpdateWithoutVideoInput, usersUncheckedUpdateWithoutVideoInput>
    create: XOR<usersCreateWithoutVideoInput, usersUncheckedCreateWithoutVideoInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutVideoInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutVideoInput, usersUncheckedUpdateWithoutVideoInput>
  }

  export type usersUpdateWithoutVideoInput = {
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    role?: roleUpdateOneWithoutUsersNestedInput
    video_comment?: video_commentUpdateManyWithoutUsersNestedInput
    video_like?: video_likeUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutVideoInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableIntFieldUpdateOperationsInput | number | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    video_comment?: video_commentUncheckedUpdateManyWithoutUsersNestedInput
    video_like?: video_likeUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type video_typeUpsertWithoutVideoInput = {
    update: XOR<video_typeUpdateWithoutVideoInput, video_typeUncheckedUpdateWithoutVideoInput>
    create: XOR<video_typeCreateWithoutVideoInput, video_typeUncheckedCreateWithoutVideoInput>
    where?: video_typeWhereInput
  }

  export type video_typeUpdateToOneWithWhereWithoutVideoInput = {
    where?: video_typeWhereInput
    data: XOR<video_typeUpdateWithoutVideoInput, video_typeUncheckedUpdateWithoutVideoInput>
  }

  export type video_typeUpdateWithoutVideoInput = {
    type_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type video_typeUncheckedUpdateWithoutVideoInput = {
    type_id?: IntFieldUpdateOperationsInput | number
    type_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type video_commentUpsertWithWhereUniqueWithoutVideoInput = {
    where: video_commentWhereUniqueInput
    update: XOR<video_commentUpdateWithoutVideoInput, video_commentUncheckedUpdateWithoutVideoInput>
    create: XOR<video_commentCreateWithoutVideoInput, video_commentUncheckedCreateWithoutVideoInput>
  }

  export type video_commentUpdateWithWhereUniqueWithoutVideoInput = {
    where: video_commentWhereUniqueInput
    data: XOR<video_commentUpdateWithoutVideoInput, video_commentUncheckedUpdateWithoutVideoInput>
  }

  export type video_commentUpdateManyWithWhereWithoutVideoInput = {
    where: video_commentScalarWhereInput
    data: XOR<video_commentUpdateManyMutationInput, video_commentUncheckedUpdateManyWithoutVideoInput>
  }

  export type video_likeUpsertWithWhereUniqueWithoutVideoInput = {
    where: video_likeWhereUniqueInput
    update: XOR<video_likeUpdateWithoutVideoInput, video_likeUncheckedUpdateWithoutVideoInput>
    create: XOR<video_likeCreateWithoutVideoInput, video_likeUncheckedCreateWithoutVideoInput>
  }

  export type video_likeUpdateWithWhereUniqueWithoutVideoInput = {
    where: video_likeWhereUniqueInput
    data: XOR<video_likeUpdateWithoutVideoInput, video_likeUncheckedUpdateWithoutVideoInput>
  }

  export type video_likeUpdateManyWithWhereWithoutVideoInput = {
    where: video_likeScalarWhereInput
    data: XOR<video_likeUpdateManyMutationInput, video_likeUncheckedUpdateManyWithoutVideoInput>
  }

  export type usersCreateWithoutVideo_commentInput = {
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    refresh_token?: string | null
    role?: roleCreateNestedOneWithoutUsersInput
    video?: videoCreateNestedManyWithoutUsersInput
    video_like?: video_likeCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVideo_commentInput = {
    user_id?: number
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    role_id?: number | null
    refresh_token?: string | null
    video?: videoUncheckedCreateNestedManyWithoutUsersInput
    video_like?: video_likeUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutVideo_commentInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVideo_commentInput, usersUncheckedCreateWithoutVideo_commentInput>
  }

  export type videoCreateWithoutVideo_commentInput = {
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    users?: usersCreateNestedOneWithoutVideoInput
    video_type?: video_typeCreateNestedOneWithoutVideoInput
    video_like?: video_likeCreateNestedManyWithoutVideoInput
  }

  export type videoUncheckedCreateWithoutVideo_commentInput = {
    video_id?: number
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    user_id?: number | null
    type_id?: number | null
    video_like?: video_likeUncheckedCreateNestedManyWithoutVideoInput
  }

  export type videoCreateOrConnectWithoutVideo_commentInput = {
    where: videoWhereUniqueInput
    create: XOR<videoCreateWithoutVideo_commentInput, videoUncheckedCreateWithoutVideo_commentInput>
  }

  export type usersUpsertWithoutVideo_commentInput = {
    update: XOR<usersUpdateWithoutVideo_commentInput, usersUncheckedUpdateWithoutVideo_commentInput>
    create: XOR<usersCreateWithoutVideo_commentInput, usersUncheckedCreateWithoutVideo_commentInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutVideo_commentInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutVideo_commentInput, usersUncheckedUpdateWithoutVideo_commentInput>
  }

  export type usersUpdateWithoutVideo_commentInput = {
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    role?: roleUpdateOneWithoutUsersNestedInput
    video?: videoUpdateManyWithoutUsersNestedInput
    video_like?: video_likeUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutVideo_commentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableIntFieldUpdateOperationsInput | number | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    video?: videoUncheckedUpdateManyWithoutUsersNestedInput
    video_like?: video_likeUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type videoUpsertWithoutVideo_commentInput = {
    update: XOR<videoUpdateWithoutVideo_commentInput, videoUncheckedUpdateWithoutVideo_commentInput>
    create: XOR<videoCreateWithoutVideo_commentInput, videoUncheckedCreateWithoutVideo_commentInput>
    where?: videoWhereInput
  }

  export type videoUpdateToOneWithWhereWithoutVideo_commentInput = {
    where?: videoWhereInput
    data: XOR<videoUpdateWithoutVideo_commentInput, videoUncheckedUpdateWithoutVideo_commentInput>
  }

  export type videoUpdateWithoutVideo_commentInput = {
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneWithoutVideoNestedInput
    video_type?: video_typeUpdateOneWithoutVideoNestedInput
    video_like?: video_likeUpdateManyWithoutVideoNestedInput
  }

  export type videoUncheckedUpdateWithoutVideo_commentInput = {
    video_id?: IntFieldUpdateOperationsInput | number
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_like?: video_likeUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type usersCreateWithoutVideo_likeInput = {
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    refresh_token?: string | null
    role?: roleCreateNestedOneWithoutUsersInput
    video?: videoCreateNestedManyWithoutUsersInput
    video_comment?: video_commentCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVideo_likeInput = {
    user_id?: number
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    role_id?: number | null
    refresh_token?: string | null
    video?: videoUncheckedCreateNestedManyWithoutUsersInput
    video_comment?: video_commentUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutVideo_likeInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVideo_likeInput, usersUncheckedCreateWithoutVideo_likeInput>
  }

  export type videoCreateWithoutVideo_likeInput = {
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    users?: usersCreateNestedOneWithoutVideoInput
    video_type?: video_typeCreateNestedOneWithoutVideoInput
    video_comment?: video_commentCreateNestedManyWithoutVideoInput
  }

  export type videoUncheckedCreateWithoutVideo_likeInput = {
    video_id?: number
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    user_id?: number | null
    type_id?: number | null
    video_comment?: video_commentUncheckedCreateNestedManyWithoutVideoInput
  }

  export type videoCreateOrConnectWithoutVideo_likeInput = {
    where: videoWhereUniqueInput
    create: XOR<videoCreateWithoutVideo_likeInput, videoUncheckedCreateWithoutVideo_likeInput>
  }

  export type usersUpsertWithoutVideo_likeInput = {
    update: XOR<usersUpdateWithoutVideo_likeInput, usersUncheckedUpdateWithoutVideo_likeInput>
    create: XOR<usersCreateWithoutVideo_likeInput, usersUncheckedCreateWithoutVideo_likeInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutVideo_likeInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutVideo_likeInput, usersUncheckedUpdateWithoutVideo_likeInput>
  }

  export type usersUpdateWithoutVideo_likeInput = {
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    role?: roleUpdateOneWithoutUsersNestedInput
    video?: videoUpdateManyWithoutUsersNestedInput
    video_comment?: video_commentUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutVideo_likeInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableIntFieldUpdateOperationsInput | number | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    video?: videoUncheckedUpdateManyWithoutUsersNestedInput
    video_comment?: video_commentUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type videoUpsertWithoutVideo_likeInput = {
    update: XOR<videoUpdateWithoutVideo_likeInput, videoUncheckedUpdateWithoutVideo_likeInput>
    create: XOR<videoCreateWithoutVideo_likeInput, videoUncheckedCreateWithoutVideo_likeInput>
    where?: videoWhereInput
  }

  export type videoUpdateToOneWithWhereWithoutVideo_likeInput = {
    where?: videoWhereInput
    data: XOR<videoUpdateWithoutVideo_likeInput, videoUncheckedUpdateWithoutVideo_likeInput>
  }

  export type videoUpdateWithoutVideo_likeInput = {
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneWithoutVideoNestedInput
    video_type?: video_typeUpdateOneWithoutVideoNestedInput
    video_comment?: video_commentUpdateManyWithoutVideoNestedInput
  }

  export type videoUncheckedUpdateWithoutVideo_likeInput = {
    video_id?: IntFieldUpdateOperationsInput | number
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_comment?: video_commentUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type videoCreateWithoutVideo_typeInput = {
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    users?: usersCreateNestedOneWithoutVideoInput
    video_comment?: video_commentCreateNestedManyWithoutVideoInput
    video_like?: video_likeCreateNestedManyWithoutVideoInput
  }

  export type videoUncheckedCreateWithoutVideo_typeInput = {
    video_id?: number
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    user_id?: number | null
    video_comment?: video_commentUncheckedCreateNestedManyWithoutVideoInput
    video_like?: video_likeUncheckedCreateNestedManyWithoutVideoInput
  }

  export type videoCreateOrConnectWithoutVideo_typeInput = {
    where: videoWhereUniqueInput
    create: XOR<videoCreateWithoutVideo_typeInput, videoUncheckedCreateWithoutVideo_typeInput>
  }

  export type videoCreateManyVideo_typeInputEnvelope = {
    data: videoCreateManyVideo_typeInput | videoCreateManyVideo_typeInput[]
    skipDuplicates?: boolean
  }

  export type videoUpsertWithWhereUniqueWithoutVideo_typeInput = {
    where: videoWhereUniqueInput
    update: XOR<videoUpdateWithoutVideo_typeInput, videoUncheckedUpdateWithoutVideo_typeInput>
    create: XOR<videoCreateWithoutVideo_typeInput, videoUncheckedCreateWithoutVideo_typeInput>
  }

  export type videoUpdateWithWhereUniqueWithoutVideo_typeInput = {
    where: videoWhereUniqueInput
    data: XOR<videoUpdateWithoutVideo_typeInput, videoUncheckedUpdateWithoutVideo_typeInput>
  }

  export type videoUpdateManyWithWhereWithoutVideo_typeInput = {
    where: videoScalarWhereInput
    data: XOR<videoUpdateManyMutationInput, videoUncheckedUpdateManyWithoutVideo_typeInput>
  }

  export type usersCreateManyRoleInput = {
    user_id?: number
    full_name?: string | null
    email?: string | null
    avatar?: string | null
    pass_word?: string | null
    face_app_id?: string | null
    refresh_token?: string | null
  }

  export type usersUpdateWithoutRoleInput = {
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    video?: videoUpdateManyWithoutUsersNestedInput
    video_comment?: video_commentUpdateManyWithoutUsersNestedInput
    video_like?: video_likeUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutRoleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    video?: videoUncheckedUpdateManyWithoutUsersNestedInput
    video_comment?: video_commentUncheckedUpdateManyWithoutUsersNestedInput
    video_like?: video_likeUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutRoleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    pass_word?: NullableStringFieldUpdateOperationsInput | string | null
    face_app_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type videoCreateManyUsersInput = {
    video_id?: number
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    type_id?: number | null
  }

  export type video_commentCreateManyUsersInput = {
    comment_id?: number
    video_id?: number | null
    date_create?: Date | string | null
    content?: string | null
    reply_list?: string | null
    timestamp?: Date | string | null
  }

  export type video_likeCreateManyUsersInput = {
    like_id?: number
    video_id?: number | null
    date_create?: Date | string | null
    dis_like?: boolean | null
  }

  export type videoUpdateWithoutUsersInput = {
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    video_type?: video_typeUpdateOneWithoutVideoNestedInput
    video_comment?: video_commentUpdateManyWithoutVideoNestedInput
    video_like?: video_likeUpdateManyWithoutVideoNestedInput
  }

  export type videoUncheckedUpdateWithoutUsersInput = {
    video_id?: IntFieldUpdateOperationsInput | number
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_comment?: video_commentUncheckedUpdateManyWithoutVideoNestedInput
    video_like?: video_likeUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type videoUncheckedUpdateManyWithoutUsersInput = {
    video_id?: IntFieldUpdateOperationsInput | number
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type video_commentUpdateWithoutUsersInput = {
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reply_list?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    video?: videoUpdateOneWithoutVideo_commentNestedInput
  }

  export type video_commentUncheckedUpdateWithoutUsersInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    video_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reply_list?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type video_commentUncheckedUpdateManyWithoutUsersInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    video_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reply_list?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type video_likeUpdateWithoutUsersInput = {
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dis_like?: NullableBoolFieldUpdateOperationsInput | boolean | null
    video?: videoUpdateOneWithoutVideo_likeNestedInput
  }

  export type video_likeUncheckedUpdateWithoutUsersInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    video_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dis_like?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type video_likeUncheckedUpdateManyWithoutUsersInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    video_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dis_like?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type video_commentCreateManyVideoInput = {
    comment_id?: number
    user_id?: number | null
    date_create?: Date | string | null
    content?: string | null
    reply_list?: string | null
    timestamp?: Date | string | null
  }

  export type video_likeCreateManyVideoInput = {
    like_id?: number
    user_id?: number | null
    date_create?: Date | string | null
    dis_like?: boolean | null
  }

  export type video_commentUpdateWithoutVideoInput = {
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reply_list?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutVideo_commentNestedInput
  }

  export type video_commentUncheckedUpdateWithoutVideoInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reply_list?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type video_commentUncheckedUpdateManyWithoutVideoInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reply_list?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type video_likeUpdateWithoutVideoInput = {
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dis_like?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: usersUpdateOneWithoutVideo_likeNestedInput
  }

  export type video_likeUncheckedUpdateWithoutVideoInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dis_like?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type video_likeUncheckedUpdateManyWithoutVideoInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    date_create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dis_like?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type videoCreateManyVideo_typeInput = {
    video_id?: number
    video_name?: string | null
    thumbnail?: string | null
    description?: string | null
    views?: number | null
    source?: string | null
    user_id?: number | null
  }

  export type videoUpdateWithoutVideo_typeInput = {
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneWithoutVideoNestedInput
    video_comment?: video_commentUpdateManyWithoutVideoNestedInput
    video_like?: video_likeUpdateManyWithoutVideoNestedInput
  }

  export type videoUncheckedUpdateWithoutVideo_typeInput = {
    video_id?: IntFieldUpdateOperationsInput | number
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_comment?: video_commentUncheckedUpdateManyWithoutVideoNestedInput
    video_like?: video_likeUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type videoUncheckedUpdateManyWithoutVideo_typeInput = {
    video_id?: IntFieldUpdateOperationsInput | number
    video_name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableIntFieldUpdateOperationsInput | number | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoCountOutputTypeDefaultArgs instead
     */
    export type VideoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Video_typeCountOutputTypeDefaultArgs instead
     */
    export type Video_typeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Video_typeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chatDefaultArgs instead
     */
    export type chatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = chatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use codeDefaultArgs instead
     */
    export type codeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = codeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use permissionDefaultArgs instead
     */
    export type permissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = permissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use roleDefaultArgs instead
     */
    export type roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = roleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use videoDefaultArgs instead
     */
    export type videoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = videoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use video_commentDefaultArgs instead
     */
    export type video_commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = video_commentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use video_likeDefaultArgs instead
     */
    export type video_likeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = video_likeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use video_typeDefaultArgs instead
     */
    export type video_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = video_typeDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}